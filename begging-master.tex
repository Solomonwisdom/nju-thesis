%% 使用 njuthesis 文档类生成南京大学学位论文的示例文档
%%
%% 作者：胡海星，starfish (at) gmail (dot) com
%% 项目主页: http://haixing-hu.github.io/nju-thesis/
%%
%% 本样例文档中用到了吕琦同学的博士论文的提高和部分内容，在此对他表示感谢。
%%
\documentclass[macfonts,master]{njuthesis}
%% njuthesis 文档类的可选参数有：
%%   nobackinfo 取消封二页导师签名信息。注意，按照南大的规定，是需要签名页的。
%%   phd/master/bachelor 选择博士/硕士/学士论文

% 使用 blindtext 宏包自动生成章节文字
% 这仅仅是用于生成样例文档，正式论文中一般用不到该宏包
%\usepackage[math]{blindtext}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multicol}
\setlength{\columnsep}{0.3cm}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%%% Coloring the comment as blue
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\SetKwInput{KwInput}{Input}                % Set the Input
\SetKwInput{KwOutput}{Output}              % set the Output



\renewcommand{\lstlistingname}{代码}
\renewcommand{\algorithmcfname}{算法}
\newcommand\YAMLcolonstyle{\color{red}\mdseries}
\newcommand\YAMLkeystyle{\color{black}\bfseries}
\newcommand\YAMLvaluestyle{\color{blue}\mdseries}

\makeatletter

% here is a macro expanding to the name of the language
% (handy if you decide to change it further down the road)
\newcommand\language@yaml{yaml}

\expandafter\expandafter\expandafter\lstdefinelanguage
\expandafter{\language@yaml}
{
  keywords={true,false,null,y,n},
  keywordstyle=\color{darkgray}\bfseries\scriptsize,
  basicstyle=\YAMLkeystyle\scriptsize,                                 % assuming a key comes first
  numbers=left,
  numberstyle=\scriptsize,
  frame=single,
  breaklines,
  columns=flexible,
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily\scriptsize,
  stringstyle=\YAMLvaluestyle\ttfamily\scriptsize,
  moredelim=[l][\color{orange}]{\&},
  moredelim=[l][\color{magenta}]{*},
  moredelim=**[il][\YAMLcolonstyle{:}\YAMLvaluestyle]{:},   % switch to value style at :
  morestring=[b]',
  morestring=[b]",
  literate =    {---}{{\ProcessThreeDashes}}3
                {>}{{\textcolor{red}\textgreater}}1
                {|}{{\textcolor{red}\textbar}}1
                {\ -\ }{{\mdseries\ -\ }}3,
}

% switch to key style at EOL
\lst@AddToHook{EveryLine}{\ifx\lst@language\language@yaml\YAMLkeystyle\fi}
\makeatother

\newcommand\ProcessThreeDashes{\llap{\color{cyan}\mdseries-{-}-}}

%\usepackage[utf8]{inputenc}
%\usepackage[english]{babel}
%
%\usepackage[outputdir=.texpadtmp]{minted}
%\usemintedstyle{borland}

\usepackage{color}
\usepackage{xcolor}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{Go}{
  % Keywords as defined in the language grammar
  morekeywords=[1]{%
    break,default,func,interface,select,case,defer,go,map,%
    struct,chan,else,goto,package,switch,const,fallthrough,%
    if,range,type, continue,for,import,return,var},
  % Built-in functions
  morekeywords=[2]{%
    append,cap,close,complex,copy,delete,imag,%
    len,make,new,panic,print,println,real,recover},
  % Pre-declared types
  morekeywords=[3]{%
    bool,byte,complex64,complex128,error,float32,float64,%
    int,int8,int16,int32,int64,rune,string,%
    uint,uint8,uint16,uint32,uint64,uintptr},
  % Constants and zero value
  morekeywords=[4]{true,false,iota,nil},
  % Strings : "foo", 'bar', `baz`
  morestring=[b]{"},
  morestring=[b]{'},
  morestring=[b]{`},
  % Comments : /* comment */ and // comment
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  basicstyle=\ttfamily\scriptsize,
  numbers=left,
  numberstyle=\scriptsize,
  frame=single,
  breaklines,
  columns=flexible,
  keywordstyle=\color{blue}\ttfamily\scriptsize,
  stringstyle=\color{red}\ttfamily\scriptsize,
  commentstyle=\color{green}\ttfamily\scriptsize,
  tabsize=4,
  % Options
  sensitive=true
}

\lstdefinelanguage{JavaScript}{
  basicstyle=\ttfamily\scriptsize,
  numbers=left,
  numberstyle=\scriptsize,
  frame=single,
  breaklines,
  columns=flexible,
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries\scriptsize,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries\scriptsize,
  identifierstyle=\color{black}\scriptsize,
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily\scriptsize,
  stringstyle=\color{red}\ttfamily\scriptsize,
  morestring=[b]',
  morestring=[b]"
}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\ttfamily\scriptsize,
    numbers=left,
    numberstyle=\scriptsize,
    frame=single,
  	breaklines,
  	columns=flexible,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 设置《国家图书馆封面》的内容，仅博士论文才需要填写

% 设置论文按照《中国图书资料分类法》的分类编号
\classification{0175.2}
% 论文的密级。需按照GB/T 7156-2003标准进行设置。预定义的值包括：
% - \openlevel，表示公开级：此级别的文献可在国内外发行和交换。
% - \controllevel，表示限制级：此级别的文献内容不涉及国家秘密，但在一定时间内
%   限制其交流和使用范围。
% - \confidentiallevel，表示秘密级：此级别的文献内容涉及一般国家秘密。
% - \clasifiedlevel，表示机密级：此级别的文献内容涉及重要的国家秘密 。
% - \mostconfidentiallevel，表示绝密级：此级别的文献内容涉及最重要的国家秘密。
% 此属性可选，默认为\openlevel，即公开级。
\securitylevel{\openlevel}
% 设置论文按照《国际十进分类法UDC》的分类编号
% 该编号可在下述网址查询：http://www.udcc.org/udcsummary/php/index.php?lang=chi
\udc{004.72}
% 国家图书馆封面上的论文标题第一行，不可换行。此属性可选，默认值为通过\title设置的标题。
\nlctitlea{声明式的通用Kubernetes}
% 国家图书馆封面上的论文标题第二行，不可换行。此属性可选，默认值为空白。
\nlctitleb{Operator的设计与实现}
% 国家图书馆封面上的论文标题第三行，不可换行。此属性可选，默认值为空白。
\nlctitlec{}
% 导师的单位名称及地址
\supervisorinfo{南京大学计算机科学与技术系~~南京市栖霞区仙林大道163号~~210023}
% 答辩委员会主席
\chairman{黄宇~~教授}
% 第一位评阅人
\reviewera{卜磊~~教授}
% 第二位评阅人
\reviewerb{陈林~~副教授}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 设置论文的中文封面

% 论文标题，不可换行
\title{声明式的通用Kubernetes Operator的设计与实现}
\titlea{声明式的通用Kubernetes}
\titleb{Operator的设计与实现}
% 如果论文标题过长，可以分两行，第一行用\titlea{}定义，第二行用\titleb{}定义，将上面的\title{}注释掉
% \titlea{半轻衰变$D^+\to \omega(\phi)e^+\nu_e$的研究}
% \titleb{和弱衰变$J/\psi \to D_s^{(*)-}e^+\nu_e$的寻找}

%%盲审命令，空白字段设置请看.cls文件\newcommand*{\blind}
%此外，请按照盲审要求自行去掉个人简历、致谢等页面中的个人信息
%\blind

% 论文作者姓名
\author{汪浩港}
% 论文作者联系电话
\telphone{15605213809}
% 论文作者电子邮件地址
\email{whg19961229@gmail.com}
% 论文作者学生证号
\studentnum{MG1833067}
% 论文作者入学年份（年级）
\grade{2018}
% 导师姓名职称
\supervisor{曹春~~教授}
% 导师的联系电话
\supervisortelphone{18951679203}
% 论文作者的学科与专业方向
\major{计算机科学与技术}
% 论文作者的研究方向
\researchfield{软件方法学}

% 论文作者所在院系的中文名称
\department{计算机科学与技术系}
% 论文作者所在学校或机构的名称。此属性可选，默认值为``南京大学''。
\institute{南京大学}
% 论文的提交日期，需设置年、月、日。
\submitdate{2021年5月25日}
% 论文的答辩日期，需设置年、月、日。
\defenddate{2021年5月25日}
% 论文的定稿日期，需设置年、月、日。此属性可选，默认值为最后一次编译时的日期，精确到日。
%% \date{2013年5月1日}
% 论文的定稿日期，需设置年、月、日。此属性可选，默认值为最后一次编译时的日期，精确到日。
%% \date{2013年5月1日}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 设置论文的英文封面

% 论文的英文标题，不可换行
\englishtitle{The Design and Implementation of A Declarative Universal Kubernetes Operator}
% 论文作者姓名的拼音
\englishauthor{Wang Haogang}
% 导师姓名职称的英文
\englishsupervisor{Professor Cao Chun}
% 论文作者学科与专业的英文名
\englishmajor{Computer Science and Technology}
% 论文作者所在院系的英文名称
\englishdepartment{Department of Computer Science and Technology}
% 论文作者所在学校或机构的英文名称。此属性可选，默认值为``Nanjing University''。
\englishinstitute{Nanjing University}
% 论文完成日期的英文形式，它将出现在英文封面下方。需设置年、月、日。日期格式使用美国的日期
% 格式，即``Month day, year''，其中``Month''为月份的英文名全称，首字母大写；``day''为
% 该月中日期的阿拉伯数字表示；``year''为年份的四位阿拉伯数字表示。此属性可选，默认值为最后
% 一次编译时的日期。
\englishdate{May 25, 2021}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 设置论文的中文摘要

% 设置中文摘要页面的论文标题及副标题的第一行。
% 此属性可选，其默认值为使用|\title|命令所设置的论文标题
% \abstracttitlea{数据中心网络模型研究}
% 设置中文摘要页面的论文标题及副标题的第二行。
% 此属性可选，其默认值为空白
% \abstracttitleb{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 设置论文的英文摘要

% 设置英文摘要页面的论文标题及副标题的第一行。
% 此属性可选，其默认值为使用|\englishtitle|命令所设置的论文标题
\englishabstracttitlea{The Design and Implementation of A Declarative}
% 设置英文摘要页面的论文标题及副标题的第二行。
% 此属性可选，其默认值为空白
\englishabstracttitleb{Universal Kubernetes Operator}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 制作国家图书馆封面（博士学位论文才需要）
%\makenlctitle
% 制作中文封面
\maketitle
% 制作英文封面
\makeenglishtitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 开始前言部分
\frontmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 论文的中文摘要
\begin{abstract}
Kubernetes是最受欢迎的容器编排系统，已经成为分布式资源调度和自动化运维的事实标准。为了适应成千上万的应用的工作模式，Kubernetes Operators被官方推荐作为在Kubernetes中打包、部署和管理应用的方法。本文工作针对Kubernetes Operator开发中存在的模版代码冗余、非功能性代码繁多、非Go语言使用者开发困难等问题，提出了一种声明式的通用Kubernetes Operator，将其命名为UniversalController，简称UC，从而实现更简单地开发和部署自定义控制器。具体而言，本文工作的主要内容包括：
\begin{enumerate}
	\item 针对Operator开发困难的问题，提出一种声明式的通用Kubernetes调谐（reconciliation）技术，封装编写自定义控制器的一般部分，将核心的自定义调谐逻辑单独抽取出来让开发者实现；添加一种新的自定义资源，用于描述自定义控制器，自定义控制器通过该自定义资源动态定义，在运行时调用实际提供调谐逻辑的服务，显著降低了Operator开发者的工作负担，帮助开发者将精力集中在核心调谐逻辑上。
	\item 实现了声明式的通用Kubernetes Operator，UC，该工具具有声明式的资源监视，声明式的调谐、声明式的更新策略和语言无关的特性，开发者不需要编写任何与Kubernetes交互的代码，只需要在YAML文件中描述需要监视的资源、使用的更新策略以及在调谐代码段中描述期望的状态即可。
	\item 基于UC重新实现了一些现有的Kubernetes Operators，验证了UC可以显著缩减开发工作量，并且适用于大部分场景的开发，并通过性能测试验证了它能在多自定义控制器部署的环境中减少内存消耗和kube-apiserver的负载。
\end{enumerate}

% 中文关键词。关键词之间用中文全角分号隔开，末尾无标点符号。
\keywords{Kubernetes；Operator；声明式；UniversalController}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 论文的英文摘要
\begin{englishabstract}
% 英文关键词。关键词之间用英文半角逗号隔开，末尾无符号。
Kubernetes is the most popular container orchestration system for automating application deployment and has become the fact standard for distributed resource scheduling and automated operations and maintenance. To accommodate the working patterns of thousands of applications, Kubernetes Operators are officially recommended as the way to package, deploy and manage applications in Kubernetes, and it is the most mainstream way for users to scale Kubernetes. The work in this paper addresses the problems of Kubernetes Operator development, such as steep learning curve, extensive non-functional code, and redundant template code. This paper proposes a declarative universal Kubernetes Operator, which is named UniversalController, or UC for short. UniversalController is helpful for developing and deploying custom controllers.Specifically, the main elements of the work in this paper include:

\begin{enumerate}
	\item To address the problem of difficult Operator development, we propose a declarative universal Kubernetes reconciliation technique that encapsulates the general part of writing custom controllers, extracts the core custom reconciliation logic separately for developers to implement and adds a custom resource to describe the custom controller.The custom controller is dynamically defined by the custom resource and invokes the service that actually provides the tuning logic at runtime.The technology significantly reduces the workload of Operator developers and helps them focus on the core reconciliation logic. 
	\item Implements a declarative universal Kubernetes Operator, named as UniversalController, with declarative resource watch, declarative reconciliation, declarative update policies, and language-agnostic features. Instead of writing any code to interact with Kubernetes, users only need to describe the resources to be listened to, the update policies to be used in a YAML file and the desired state in the reconciliation snippet.
	\item Based on UniversalController, some existing Kubernetes Operators were re-implemented, proving that UniversalController can greatly reduce development effort and is suitable for most scenarios. Performance testing also verified that it can reduce memory consumption and kube-apiserver load in environments with multiple custom controller deployments.
\end{enumerate}

\englishkeywords{Kubernetes；Operator；Declarative；UniversalController}
\end{englishabstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 生成论文目次
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 生成插图清单。如无需插图清单则可注释掉下述语句。
\listoffigures

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 生成附表清单。如无需附表清单则可注释掉下述语句。
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 开始正文部分
\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 学位论文的正文应以《绪论》作为第一章
\chapter{绪论}\label{chapter_introduction}
\section{研究背景}

在过去十年中，软件系统的开发、托管、交付和扩展方式发生了根本性的转变。大规模分布式应用不断产生，新的需求也不断产生，集群管理人员希望应用能够快速地根据用户流量的波动调整，同时最大限度地降低IT基础设施的管理成本，这些都为云技术被广泛采用铺平了道路。正如Netflix或Zalando等颇具规模的互联网科技公司所展示的那样，软件开发的方式和方法已经从每年几次的大型单体应用的计划驱动交付转变为由数百个单一用途的服务组成的系统，一天内有多个版本的迭代\cite{zalando}\cite{netflix}。

尽管云计算具有相当的灵活性，但随着应用和平台的复杂性增加，仍然需要对基础应用、基础设施和相关流程进行创新与改进。应用程序和基础设施运营团队在管理基础设施方面正面临着挑战，这些基础设施需要同时支持数百甚至数千的应用程序。在这种情况下，传统的自动化方法，如使用特制的、指令式的脚本，被证明是难以管理和扩展的。

最近越来越流行的自动化管理或运维工具旨在遵循基础设施即代码（Infrastructure as code，IaC）原则。根据这一原则，基础设施和核心服务的整体配置和状态要用（典型的声明性）代码来定义。借助相关工具，这个刻画了期望状态定义的代码，可以自动转换为正确的指令和API调用，从而产生完全符合期望状态的配置资源。这种将实际状态与期望状态的定义同步的过程被称为``状态调谐''（state reconciliation），一些现代的基础设施和云计算自动化工具都采用了这种方法，其中最受欢迎的是基于容器的平台Kubernetes。

Kubernetes已经开始被广泛应用于基础设施自动化和状态调谐的使用场景。它是目前最受欢迎的容器化应用程序的管理平台，它从一开始就围绕着状态调谐的概念设计。整个架构可以被认为是一个各个模块通过共享状态存储协作的调谐循环系统。此外，可扩展性是Kubernetes设计中的一个核心方面。基于这两个特点，Kubernetes也被用作一个通用的状态调谐引擎，能够调谐定制的、特定于应用程序的资源和状态，这些资源和状态可以是Kubernetes本身的外部资源，如云提供商资源或虚拟数据中心设备。为了利用这些功能，应用程序需要正确有效地处理与Kubernetes API的通信和集成，这些并不是简单的工作。由于Kubernetes仍然是一个相对年轻的项目，试图解决这种复杂性的可用库非常少。Kubernetes本身与许多其他容器和云原生技术类似，是用Go语言编写的，所以最成熟的集成和扩展库也是用Go语言编写的。也就是说，只要相关的代码都可以用Go语言编写，开发体验会是最好的。这对于一部分开发者和公司是可能的，但大部分其他语言的开发者将不得不放弃许多已有的标准和工具。支持更多编程语言的Kubernetes抽象库才会让更多人收益。

Kubernetes具有很好的开放性与可拓展性，开发人员可以通过CustomResourceDefinition（简称CRD）机制来拓展Kubernetes的声明式API，将自定义资源添加到Kubernetes集群中，再开发部署作用于这些资源的自定义控制器（Custom Controller）执行自定义的调谐。这种``CRD+自定义控制器''的模式被称为Operator，也是最常用的扩展Kubernetes的方式。Operator的概念是由coreOS提出的，是对Kubernetes的软件拓展，帮助实现应用程序的自动化部署、升级、管理以及运维\cite{operators}。然而，编写一个Operator并不容易，具有相当高的门槛，并且需要付出大量的精力和时间。Operator开发人员需要具备一定程度的Kubernetes和分布式系统知识，需要写大量的模版代码或者使用代码生成工具。编写出的Operator帮助我们实现了应用程序的自动化运维，但是维护这个Operator却还是要给开发人员带来很大的负担\cite{problemofoperators}。因此诞生了很多工具，它们都希望帮助开发人员更简单的实现自己的Operator。本文提出的UniversalController是一个声明式的通用Operator，可以有效减轻开发人员的开发与运维负担。

\section{研究现状}

现阶段开发Kubernetes Operator主要有两种方式，分别是使用现有的Kubernetes客户端库和使用基于controller-runtime库的SDK工具。Kubernetes客户端库提供了一系列用于与Kubernetes交互的接口，而SDK工具使用基于客服端库的高级抽象库，同时提供了一些开发辅助工具，例如代码生成工具和代码规范检查工具等。

在开发Operator时，最常用且灵活的做法是使用现有的Kubernetes客户端，包括Go、Java、JavaScript/TypeScript或其他语言的客户端。这些客户端提供了对Kubernetes API的直接底层访问，没有任何包装或附加层。其中最成熟的是Go客户端client-go\footnote{https://github.com/kubernetes/client-go}，它提供了很多基础组件，可以用于自定义控制器的开发。但是client-go不是一个专门用于实现自定义控制器的库，而是为了更通用的场景而设计的，用它来实现Operator需要接触到太多的底层接口，十分繁琐，而且模版代码与非功能性代码很多。

为了简化Operator的开发，目前的方法主要是使用SDK工具，它使用更高级的自定义控制器开发库，屏蔽了底层的接口，同时使用代码生成工具来生成模版代码，帮助开发者搭建项目基础脚手架，减轻了编程负担。Kubernetes-sigs\footnote{https://github.com/kubernetes-sigs}团队开源的kubebuilder和coreOS开源的Operator SDK都是基于这个思路产生的。与Ruby on Rails和SpringBoot等Web开发框架类似，Kubebuilder和Operator SDK提高了开发人员使用Go语言快速构建和发布Kubernetes API的速度并降低了管理的复杂性。它们都使用了高级抽象库controller-runtime\footnote{https://github.com/kubernetes-sigs/controller-runtime}，建立在用于构建核心Kubernetes API的规范技术之上，以提供简单的抽象，减少模板和编码量。它们减轻了工作量，给出了脚手架，定义了一套自己的编程规范，但是也带来了一些问题。开发者不按照规范走就无法使用代码生成工具，而它们的版本兼容性存在问题，新版本的编程规范会与旧版本冲突，导致升级后无法使用，必须手动修改相关代码实现迁移。

对于其他编程语言的使用者，Operator的开发体验很不友好，没有类似controller-runtime的高级抽象库，甚至官方提供的客户端都还不够成熟，例如C\#客户端的监视接口没有提供连接断开后自动重连的功能，需要开发者自己编写代码处理；JavaScript客户端缺少错误处理机制。而使用SDK工具生成的代码依然是用Go编写的，整个项目依然是一个Go项目，开发者依然需要具备Go语言和Kubernetes相关依赖库的基础知识\cite{problemofoperators}。

\section{本文工作}
本文针对现有Operator开发方式中存在的模版代码冗余、非功能性代码繁多、非Go语言使用者开发困难等问题，提出了一种声明式的通用Kubernetes调谐技术。该技术采用的方法是（1）封装编写自定义控制器的一般部分，例如资源监视、当前状态与期望状态对比、资源更新等；（2）将核心的自定义调谐逻辑单独抽取出来让开发者实现，并通过服务端应用实现声明式开发；（3）扩展Kubernetes的API，添加一种新的自定义资源，用于描述自定义控制器，自定义控制器通过该自定义资源动态定义，在运行时调用实际提供调谐逻辑的服务。该技术为开发者开发Operator提供一种简单的声明式方法，让开发者将注意力完全集中在核心调谐逻辑上，摆脱Go语言、Kubernetes开发工具包、代码生成工具的学习与使用成本。自定义资源和自定义控制器都借助Kubernetes的声明式API创建，而且开发者可以使用任意可以处理JSON和网络请求的编程语言来实现一个Operator。

本文将基于声明式的通用Kubernetes调谐技术实现的工具称为UniversalController，它是一个声明式的通用Kubernetes Operator，底层实现依然是经典的Operator模式。借助UniversalController提供的声明式API，尤其是声明式调谐接口，开发者为核心业务逻辑编写的代码也是声明式的，可以用任意一种能够处理JSON\footnote{https://www.json.org/json-en.html}的编程语言来实现，只需要用JSON编写期望存在的资源即可。如果开发者已经很熟悉使用YAML编写资源定义文件并用``kubectl apply''命令部署来管理应用这种基本的Kubernetes使用方式，那么就可以很容易地基于UniversalController实现一个Operator为应用的部署、更新、维护提供自动化流程而不必去学习Go语言或者如何使用Kubernetes客户端库，也不需要去学习使用代码生成工具。本文工作主要包括：

\begin{enumerate}
	\item 针对Operator开发中存在的模版代码冗余、非功能性代码繁多、非Go语言使用者开发困难等问题，提出一种声明式的通用调谐技术，封装编写自定义控制器的一般部分，将核心的自定义调谐逻辑单独抽取出来让开发者实现；添加一种新的自定义资源，用于描述自定义控制器，自定义控制器通过该自定义资源动态定义，在运行时调用实际提供调谐逻辑的服务。该技术简化需要编写的代码，大量减少Operator开发者的工作量，帮助开发者将精力集中在业务逻辑上，即描述期望状态上。
	\item 基于声明式的通用调谐技术实现了声明式的通用Kubernetes Operator，UniverslController，该工具具有声明式的资源监视，声明式的调谐、声明式的更新策略和语言无关的特性，开发者不需要编写任何与Kubernetes交互的代码，只需要在YAML文件中描述需要监视的资源、使用的更新策略以及在调谐代码段中描述期望的状态即可。该工具帮助开发者免除学习Kubernetes客户端库、控制器抽象库或其他工具的负担，也消除了编写或生成模版代码的必要。
	\item 基于UniversalController重新实现了一些现有的Operators，验证了UniversalController可以显著缩减开发工作量，并且适用于大部分场景的开发，并通过性能测试验证了它还能在多自定义控制器部署的环境中减少内存消耗和kube-apiserver的负载。
\end{enumerate}


\section{论文结构}
本文接下来的内容组织结构如下：

%第\ref{chapter_introduction}章 绪论。本章对Kubernetes的流行程度，Kubernetes Operator在其中扮演的角色和意义、现阶段开发Operator存在的问题以及本文针对这些问题所做的工作做了简单的介绍。

第\ref{chapter_relative}章 相关工作和技术。本章主要介绍Kubernetes Operator所涉及到的关键技术与工作。首先介绍了现代基础设施的特征和面临的挑战，之后深入到一个具体的、流行的做法，基础设施即代码，然后给出状态调谐的定义和细节，最后深入探讨了Kubernetes系统和它如何应用和实现状态调谐的细节。

第\ref{chapter_framework}章 声明式的通用Kubernetes调谐技术。本章首先对现有的Operator开发方式进行了分析，指出问题所在。然后解释如何通过声明式的通用调谐技术解决这些问题。

第\ref{chapter_implement}章 声明式的通用Kubernetes Operator的设计与实现。本章详细描述本文提出的UniversalController的设计思想与具体实现。

第\ref{chapter_experiments}章 实验评估。本章介绍通过UniversalController实现了若干个Operators，并对它们分别进行测试，验证UniversalController的通用性和有效性。

第\ref{chapter_concludes}章 总结和展望。总结本文所做的工作，并对UniversalController的未来发展做出进一步展望。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{相关工作和技术}\label{chapter_relative}

\section{基础设施即代码}

Morris将基础设施即代码（IaC）定义为一种基于软体开发实践的基础设施自动化方法，重点在于提供和改变系统及其配置的一致、可重复的程序\cite{morris2016infrastructure}。现代基础设施的生命周期正变得与应用程序越来越相似，现代基础设施的组件更加抽象，可以根据需要立即配置和改变它们，这意味着迭代和改变的速度也在增加。使用IaC，基础设施的每个方面都在一个或多个文件中使用某种形式的代码来定义。有了这个规则，就可以设计出利用自动化工具的流程，以便根据代码文件中定义的规范，自动提供资源或对基础设施进行修改。

\begin{figure}[htbp]
  \centering
  \includegraphics[width= 1\textwidth]{pics/IaC.pdf}\\
  \caption{典型的IaC工作流程}\label{fig:IaC}
\end{figure}

在一个典型的IaC工作流程中，如图\ref{fig:IaC}所示，为了进行一次变更，基础设施工程师会在一个包含基础设施代码的文件中表达这个变更。与应用程序代码类似，该代码可以被提交到版本控制系统的存储库中。之后，代码被推送到自动化系统或由自动化系统拉出，随后自动化系统使用该文件和平台特定的集成功能，在基础设施中应用所描述的变更\cite{whatisiac}。

包含基础设施代码的文件被称为定义文件，使用定义文件来描述基础设施是基础设施即代码的核心。按照更传统的方法，基础设施资源通常是用自动化系统的图形界面来定义，并存储在其数据库中，或者根本没有严格的定义，只是在图表和规范文件中记录。按照基础设施即代码的方法，基础设施的所有方面和资源都被定义为代码，也就是定义文件\cite{morris2016infrastructure}。使用定义文件有几个好处。首先，它们允许精确和详细地描述基础设施资源。其次，对定义的修改可以通过一个文本编辑器来完成，这通常比使用图形界面更快、更简单。最后，定义文件有助于使基础设施更加一致和可重复使用，因为文本定义可以通过最小的调整来适应新的使用情况。另外，根据所使用的IaC工具和语言，可以使用更高层次的编程结构，如模板和函数，以进一步简化这一过程\cite{morris2016infrastructure}\cite{whatisiac}。

自文档是使用基础设施即代码和定义文件可以得到的直接好处。在传统的方法中，变化的实施和文档是两个独立的过程，这往往会导致文档过时或不存在。因为随着频繁的变化，要保持文档的更新是一个挑战。通过使用精确和详细的代码在定义文件中定义基础设施，代码和文件会自动触发相应行为，并可作为基础设施的文档\cite{morris2016infrastructure}\cite{whatisiac}。

使用代码和文件来描述基础设施，使得软件工程中最广泛使用的做法之一，即版本控制，能够被用于基础设施。使用像Git这样的版本控制系统（VCS），代码可以在代码仓库中进行组织和版本管理。对代码所做的每一个改动都必须提交到版本控制系统中，版本控制系统会跟踪所有改动的历史，并支持在历史的不同点上查看代码库的不同状态（快照）。因此，代码仓库可以作为代码的可信来源。首先，对所有基础设施的定义有一个单一的可信来源，可以改善协作和变化的一般可见性，因为历史日志可以作为一个易于使用的时序的变化描述。其次，这也允许可追溯性和可审计性，因为每一个变更都可以追溯到VCS中的提交，而提交中通常都有关于做出变更的人的信息，也有关于变更的描述或理由。最后，历史日志和VCS的操作也可以在回滚时有所帮助，基础设施可以恢复到一些经过测试的安全状态。

IaC的相关工具大致分为以下四类\cite{whatisiac}。

\paragraph{脚本工具}

使用常见的操作系统脚本工具和语言，如Bash、Powershell、Python、Perl等，是使用代码管理基础设施的最简单方法。虽然它们足以完成简单的任务，但这些工具在更复杂的情况下不能很好地扩展。这些工具本质上使用的是指令式的方法。

\paragraph{配置惯例系统}

配置惯例系统是一套功能更全面的系统，如Chef、Puppet或Ansible，它们通常用于以通用方式管理服务器。这些工具倾向于使用标准或专门的远程连接协议和代理与服务器直接通信，以便对软件进行安装和配置。一般来说，这类工具倾向于使用特定的概念和术语，指令式和声明式的工具都可以找到。

\paragraph{配置（provisioning）工具}

这类工具通常提供更高层次的抽象，允许开发者创建、修改和删除动态基础设施平台的资源。其中最知名的例子是AWS CloudFormation和Terraform。两者都采用声明式方法，其中CloudFormation使用JSON，Terraform使用自定义的、特定领域的配置语言（DSL）来定义文件。CloudFormation是专门针对AWS平台的，而Terraform则可以在许多不同的平台上使用，因为它可以通过定制的供应商来扩展，几乎可以用于任何符合动态基础设施要求的平台。另外，大多数动态平台也以命令行工具或软件库的形式提供指令式配置工具，如AWS或Google SDK。

\paragraph{基于容器的编排系统}

基于容器的编排系统通常是以IaC原则设计的全动态基础设施平台。这方面的例子有Docker Swarm、Kubernetes、Nomad等等。其核心是提供一个基础设施级别的抽象，如计算、存储和网络。容器的内在特征使IaC成为可能，容器封装了单个应用环境的全部内容，可以用代码（如Dockerfile）来定义，并打包成一个不可变的镜像。此外，容器编排系统（如Kubernetes、Nomad）通过允许系统中的所有资源被声明性地定义，进一步拥抱IaC。

\section{状态调谐}\label{section:reconciliation}

在这一节中，我们将探讨一种在大多数声明式IaC工具和系统中常见的模式，并从一般的角度讨论其变化和用途，这种模式被称为状态调谐（state reconciliation）。

\subsection{从实际状态到期望状态}

声明式IaC工具的基本特征之一是能够接受对期望状态（如特定的基础设施资源集）的描述，并自动变更实际状态（如AWS账户中配置的对象/服务），使其反映期望状态。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{pics/simple-state-reconciliation.pdf}\\
  \caption{状态调谐}\label{fig:ssr}
\end{figure}

图\ref{fig:ssr}中的这种模式就是状态调谐，它被定义为使实际状态与目标状态一致的过程。在本文中，状态调谐将主要在软件应用程序和基础设施的管理中被考虑，因此，在大多数情况下，目标状态将被视为所需的、开发者定义的状态，如基础设施代码，而实际状态将被视为被管理的平台、基础设施或应用的状态。

\subsection{连续状态调谐}\label{section:continus-reconciliation}

在很多情况下，调谐过程是按需触发的（例如，由开发者手动触发，或因基础设施代码的新变化而自动触发），许多IaC工具，包括Terraform，都采用这种方法。这种方式有一个缺点，那就是只有在一次调谐过程结束后，两个状态（期望的和实际的）的一致性才能实现。在任何时候，某些事件，例如绕过IaC对基础设施进行的手动变更，都可能导致两个状态之间的不一致和漂移。通过这种一次性的方法，导致的不一致直到下一次触发调谐过程时才会被解决，而这可能要到下一次对IaC代码修改时才会发生。更先进的系统，如Kubernetes中的调谐功能，能够通过不断观察调谐循环中的状态并做出反应，持续尝试确保一致性。这种方法在本论文中被称为连续状态调谐。

一个基本的实现方法是在定时器的提醒下定期执行一个新的调谐过程。这个解决方案很朴素但是在变化率较低的环境中很合适。然而，为了及时对变化做出反应，环境中的变化越频繁，调谐的时间间隔就需要越短，这会产生负载和性能影响。

一个改进方法是以基于事件的方式执行调谐过程，每次调谐作为对表明发生变化的事件的反应。例如，如果使用图\ref{fig:IaC}中的IaC工作流程，那么期望状态方面的事件可以是版本控制中的一个新变更。此外，调谐系统也需要接收关于基础设施（实际状态）中的资源变化的事件并作出反应。通过对来自双方（期望状态和实际状态）的事件的反应进行调谐，调谐过程只在需要的时候运行，这可以大大改善性能并减少负载。基于事件的方法是否可以实现，取决于实际状态背后的平台，它必须支持产生关于其资源变化的事件。Kubernetes系统原生支持这一点，这是其主要卖点之一。

\section{Kubernetes}

Kubernetes在很大程度上利用了\ref{section:reconciliation}节中定义的状态调谐模式。本节进一步深入Kubernetes，描述它的架构以及它对状态调谐的使用，最重要的是它的API可扩展性特征。

正如Kubernetes的文档中所说，它是一个可移植的、可扩展的、开源的平台，用于管理容器化的工作负载和服务。该平台促进了声明式配置和自动化\cite{whatisk8s}。在高层次上，Kubernetes作为一个开源的、与供应商无关的平台，以容器的形式托管应用程序和工作负载，这些容器在节点池上被动态地调度。它为网络、存储和其他基础设施层面的问题提供了抽象，并为配置外部资源（如负载均衡器或云中的块存储）提供了集成。容器化是操作系统级的虚拟化，是操作系统的一种功能，操作系统内核允许存在多个孤立的开发者空间实例，这些实例被称为容器。容器功能类似于虚拟机，但是，与虚拟机不同的是，容器化允许应用程序使用与它们所在的系统相同的Linux内核，而不是创建一个完整的虚拟操作系统。

\subsection{Kubernetes集群架构}

图\ref{fig:k8s-arch}是Kubernetes集群架构，由一组相对较小的组件组成，它们主要通过向一个共同的元数据库读写数据进行合作和交流。在一个典型的集群中，有两组节点：建立控制平面集群的主节点和实际运行应用程序的工作节点。组件被分成两组：控制平面组件和工作节点组件。在大多数配置中，控制平面组件只驻留在主节点上，而工作节点组件是通用的，驻留在所有的节点上\cite{k8scomponents}。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{pics/Kubernetes-architecture.pdf}\\
  \caption{Kubernetes架构图}\label{fig:k8s-arch}
\end{figure}

\subsubsection{Kubernetes控制面（control plane）}
如图\ref{fig:k8s-ctrl}所示，Kubernetes控制面由运行在主节点上的各种组件组成。与本文工作相关的主要有以下几个组件：

\paragraph{etcd（元数据库）}

etcd对于Kubernetes跨节点工作至关重要，因为它提供了一个轻量级和分布式的键值存储，可以跨越多个节点。Kubernetes使用etcd来存储配置数据，这些数据可以被集群中的每个节点访问。它存储了Kubernetes的所有配置与状态相关的数据，是系统的核心。

\paragraph{kube-apiserver}
kube-apiserver是整个集群的主要控制模块。etcd负责可靠地存储所有的元数据，但组件并不直接操作这些数据，而是由kube-apiserver提供便利。这个组件作为etcd之上的一层，承载着Kubernetes API。所有的管理工具，包括Kubernetes命令行工具kubectl，都是通过它暴露的那些API与Kubernetes进行通信的。 kubectl是默认的从本地计算机与Kubernetes集群交互的方法，允许管理集群、部署及管理Kubernetes对象。``kubectl apply''是最常用的部署命令。


\begin{figure*}[h]
\begin{multicols}{2}
\includegraphics[width=\linewidth]{pics/K8s-ctrl-plane.pdf}\\
\caption{Kubernetes控制面\cite{gorillaguide}}\label{fig:k8s-ctrl}\par

\columnbreak

~\\[140pt]

  \includegraphics[width=\linewidth]{pics/K8s-node-server-components.png}\\
  \caption{Kubernetes节点服务组件\cite{gorillaguide}}\label{fig:k8s-node}\par
\end{multicols}
\end{figure*}





\paragraph{kube-controller-manager}
kube-controller-manager是一个具有许多职责的通用服务，可以将其视为控制器组件的集合。这其中的每一个控制器都会调节集群的状态，管理工作负载生命周期，或者执行常规任务\cite{gorillaguide}。

当检测到一个变化时，控制器读取新的信息并执行满足所需状态的程序。这可能涉及到扩大或缩小应用程序的规模，调整端点等。例如，ReplicaSet确保为一个应用程序定义的副本数量与当前部署在集群上的数量相匹配。这里的每个控制器与开发者实现的自定义控制器一样都遵循\ref{section:controller-pattern}节所述的控制器模式。

\subsubsection{工作节点组件}
Kubernetes控制面组件只需要部署在主服务器上，而工作节点组件也必须安装在每个节点上，图\ref{fig:k8s-node}展示了这些组件。

\paragraph{容器运行时}
容器运行时负责启动和管理容器。Docker是典型的容器运行时，同时还有很多其他的选择，例如podman、containerd等，云提供商也可以提供自己定制的容器运行时来满足这一组件要求。

\paragraph{kube-proxy}
kube-proxy负责在节点之间创建网络，从而让节点加入Kubernetes集群接收流量。它还将传入节点的请求转发到正确的容器，也实现了一些基本形式的负载均衡。另外，它确保每个网络环境的正确隔离。

\paragraph{kubelet}
Kubelet负责与控制面服务交换信息。它从主节点组件接收命令和任务。任务以manifest的形式接收，manifest定义了要部署的资源和操作参数。在接收到一堆任务后，kubelet会负责执行工作和维护节点服务器上相关资源，一切都通过与容器运行时的交互来完成。

\subsection{Kubernetes中的状态调谐}\label{section:controller-pattern}

Kubernetes中的大部分组件和功能都是以\ref{section:reconciliation}节中描述的连续的、基于事件的状态调谐模式实现的。状态调谐的使用被包含在被称为控制器的服务中，其名称基于控制理论中的控制循环的概念，是一个调节系统状态的无限循环\cite{k8scontroller}。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{pics/Control-Loop.pdf}\\
  \caption{调谐循环}\label{fig:k8s-controller-pattern}
\end{figure}

%\begin{figure}[htbp]
%  \centering
%  \includegraphics[width= 0.8\textwidth]{pics/controller-pattern.pdf}\\
%  \caption{Kubernetes中的一个控制器}\label{fig:k8s-controller-pattern}
%\end{figure}

一个控制器通过Kubernetes API不断监视Kubernetes状态中的一些对象的变化。被监视的对象，特别是它们的规格属性，描述了一些期望的状态，控制器将试图在现有环境的相关部分（实际状态）达到这些状态。控制器包含如图\ref{fig:k8s-controller-pattern}所示的调谐循环，执行如\ref{section:continus-reconciliation}节所定义的连续状态调谐。控制器可以对一个事件做出响应，更新etcd中的一些资源，或更新一些外部环境（如云提供商的资源），或两者都更新。\ref{section:reconciliation}节所定义的期望状态和实际状态的划分，在不同的控制器实现和它们被设计用来解决的问题之间是不同的。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{pics/rs-control-loop.pdf}\\
  \caption{ReplicaSet调谐循环示例}\label{fig:rs-control-loop}
\end{figure}

图\ref{fig:rs-control-loop}是一个ReplicaSet调谐循环示例，ReplicaSet是Kubernetes原生资源，用于保证固定数量的副本部署在系统中，这个例子中ReplicaSet控制器会监视ReplicaSet和Pod，图\ref{fig:rs-control-loop}中这次调谐的父资源期望有3个副本Pod，但是系统中实际只有两个副本Pod，分析后控制器的操作就是新建一个副本Pod。


\section{Kubernetes Operator}

正如本节所讨论的，状态调谐是Kubernetes的核心，Kubernetes及其API的许多方面和功能都有助于实现调节循环和控制器。基于调谐的持续控制方法代表了一种通用模式，可以用于实现Kubernetes核心功能以外的用例，包括Kubernetes特有的自动化或者扩展，也包括完全自定义的应用，能够实现具有自定义逻辑的调谐循环也是Kubernetes可扩展性的核心体现。而实现具有自定义逻辑的调谐循环的最常用方法就是Operator。这个术语是指将控制器模式（\ref{section:controller-pattern}节）应用于一些定制的、特定领域的用例。遵循这种模式的服务被称为控制器，并与一个CRD（见\ref{section:CRD}节）配对。

Kubernetes官方文档将Operator描述为``Kubernetes的软件扩展，利用自定义资源来管理应用程序及其组件''\cite{k8soperator}。一个Operator本质上就是一个自定义资源类型和一个监视该资源类型并做出实际操作的自定义控制器的组合。控制器是Kubernetes中的一个核心概念，它被实现为一个控制循环，在Kubernetes中的一个Pod内持续运行，它比较对象的期望状态和当前状态，并在需要时随时调和这种状态。事实上，当对象的当前状态与期望状态不同时，负责管理的Kubernetes Operator会对对象发出指令，使其最终达到期望状态。和一般的IaC工具一样，期望状态和当前状态中的两个状态的含义是不同的，期望状态更接近于配置，当前状态则是实际的集群和部署在它之上的应用的状态。下面介绍一些开发者实现Operators所使用的主要工具。

\subsection{自定义资源定义（CustomResourceDefinitions）}\label{section:CRD}

为了实现自定义调谐，有必要用单独的自定义模式（schema）来定义新的自定义资源。在Kubernetes中，这可以通过使用自定义资源定义来完成，自定义资源定义的简称是CRD，是Kubernetes中的一种特殊资源类型。CRD类型资源的结构提供了一些字段，它们被用于指定应添加到Kubernetes API中的自定义资源。一旦提交了有效的CRD，Kubernetes API将自动扩展新的端点，其URL结构取决于一些字段。同时，该资源也将变得可用，可以通过kubectl命令行客户端查询和操作。该资源将自动支持所有Kubernetes API动作。核心字段的意义如下：

\paragraph{API Group}

API Group是一个需要为新的自定义资源指定的属性。API Group的概念被用于大多数Kubernetes资源（除了像Pod这样的核心资源），将相关的资源类型组合在一起，并创建一个Kubernetes API的逻辑``分区''。该组成为API端点的URL的一部分，也是自定义资源元数据的一部分，也可用于权限控制。使用域名来命名API组是很常见的，以表明所有权或作者。CustomResourceDefintion作为一种Kubernetes资源，如YAML文件\ref{listing:1}第1行所示，它所属的API Group是apiextensions.k8s.io

\paragraph{Versions}

CRD的规范还需要为新资源指定至少一个版本。版本中需要指定新资源结构，使用OpenAPI6的模式规范。每个版本都可以被启用或禁用，而且其中一个版本必须被配置为存储版本。存储版本代表实际将被存储在etcd中的结构，而其他版本将简单地被转换为存储版本。

\paragraph{Names}

要声明一个新的Kubernetes API资源，需要指定其名称的几种形式。复数名称（YAML文件\ref{listing:1}第12行的universalcontrollers）将被用于Kubernetes API端点的资源的URL结构中，即/apis/universalcontroller.njuics.cn/v1alpha1/universa-lcontrollers。单数名称（第10行）通常用于kubectl CLI命令，例如，kubectl get universalcontroller。也可以为其定义更短的别名，如YAML文件\ref{listing:1}的第13到15行所示。最后，必须指定的最后一个名称是kind，它是资源类型的名称，在配置清单中使用。

\paragraph{Scope}

CRD还必须指定新资源的作用范围。一般来说，在Kubernetes中，一个特定的资源类型可以是命名空间范围的，即每个对象必须属于某个命名空间，或者是集群范围的，即每个对象是全局的。在CRD中，这是用范围参数指定的，如YAML文件\ref{listing:1}的第17行。

\subsection{自定义控制器}

一旦新的CRD被注册，它所指定类型的自定义资源对象就可以被应用到Kubernetes。但这仅仅允许声明和存储所描述的状态，还需要有一个自定义控制器，以便将自定义资源对象的规格应用到真实的状态或环境中。自定义控制器需要使用监视API去监视这个新资源对象的相关事件，并对事件作出响应行为。

自定义控制器不是Kubernetes原生的一部分，需要开发者自行开发后单独安装。由于所有的逻辑和依赖都包含在控制器的代码中，可以通过简单地在容器中部署控制器来完成安装，例如使用与在Kubernetes中部署其他应用程序时所用的方法：添加一个新的Pod或一个Deployment（一组副本Pod）对象。

\section{对Operator实现的支持}\label{section:wayofimplement}

大部分Operator的开发者都会使用Go语言进行开发，可以选择使用底层库client-go或者高级抽象库controller-runtime来开发自定义控制器。

\subsection{client-go}


\begin{figure}[htbp]
  \centering
  \includegraphics[width= 1\textwidth]{pics/client-go-controller-interaction.pdf}\\
  \caption{控制器工作方式}\label{fig:client-go-controller-interaction}
\end{figure}

client-go是最成熟的Kubernetes客户端库，它和Kubernetes自身一样都由Go语言编写而成，是Kubernetes官方第一个提供的客户端库，而且正在被Kubernetes本身的组件内部使用，这也意味着它是经过良好测试和可靠的\cite{controllerclientgo}。

该库封装了几个抽象和较小的包，便于实现Kubernetes的集成和与Kubernetes API的通信。有三个包与基本的Kubernetes API通信有关\cite{controllerclientgo}：

\begin{enumerate}
	\item kubernetes包，提供静态（和静态类型）的客户端，可用于对Kubernetes API执行涉及Kubernetes原生资源类型的操作；
	\item dynamic包，它提供了一个动态客户端，能够对任何资源类型（原生和自定义）进行通用操作；
	\item transport包，在与Kubernetes通信时帮助处理低级别的传输细节，如使用有效的认证建立连接等。
\end{enumerate}

此外，由于client-go在整个Kubernetes代码库中被使用，包括复杂的场景，它还附带了额外的工具、实用程序、对象和抽象，以简化Kubernetes集成。

图\ref{fig:client-go-controller-interaction}展示了使用clieng-go编写的控制器的工作方式。首先介绍一下client-go提供给开发者的组件：
\begin{enumerate}
	\item \textbf{反射器（Reflector）}：反射器监视着Kubernetes API中的指定资源类型（Kind）。完成这项工作的方法（function）是``ListAndWatch''。监视的对象可以是内置的原生资源，也可以是自定义资源。当反射器通过监视API收到有新资源诞生的通知时，它使用相应的listing API获得该对象，调用``watchHandler''方法，将其放入``Delta FIFO''队列中；
	\item \textbf{通知器（Informer）}：通知器从``Delta FIFO''队列中弹出对象。它的工作是保存对象以便以后检索，并向自定义控制器传递对象；
	\item \textbf{索引器（Indexer）}：索引器提供索引对象的功能。一个典型的索引用例是基于对象标签创建索引。索引器可以基于几个索引功能来维护索引。索引器使用一个线程安全的数据存储来存储对象和它们的键。默认会使用Store类型中一个名为MetaNamespaceKeyFunc的方法来生成键，该方法将一个对象的键生成为该对象的<命名空间>/<名称>组合。
\end{enumerate}

鉴于本文的主题与状态调谐和自定义Kubernetes控制器有关，客户端最引人注目的功能是Informer模式的实现\cite{informer}。Informer是对Kubernetes API的实时观察功能的抽象，API可以将集群中任何对象的任何变化事件通知消费者。它们提供了一个接口，允许开发者为特定的Kubernetes资源类型有效地建立所述的变化流连接\cite{informer}。这代表了实现自定义控制器的关键功能，它需要不断监视和应对资源相关变化的。

而自定义控制器中有以下组件：
\begin{enumerate}
	\item \textbf{资源事件处理器（Resource Event Handlers）}：资源事件处理器是回调函数，当通知器（Informer）向控制器传递一个对象时，它将被调用。编写这些函数的典型模式是获取被传递对象的键，并将该键排入工作队列（workqueue）等待进一步的处理；
	\item \textbf{工作队列（Workqueue）}：工作队列将对象的传递与处理脱钩，接受到对象后不会立即处理而是放入队列中；
	\item \textbf{处理程序（Process Item）}：处理程序被用于处理工作队列中的项目，它通常使用索引器来检索与键对应的对象。
\end{enumerate}

\subsection{controller-runtime}

controller-runtime建立在client-go库之上，用构建控制器的相关概念和API来扩展它，其中包括读写Kubernetes对象的高级客户端、用于高效获取Kubernetes对象的缓存、用于共享依赖关系和启动控制器的管理器（Manager）、核心抽象控制器、用于扩展Kubernetes API的对象准入流程的Webhook、由事件触发执行的调谐器、封装Kubernetes事件流的源\cite{k8s-sigs}。



\section{小结}
本章主要介绍了声明式的通用Kubernetes Operator涉及的相关技术和场景。首先介绍了动态基础设施及其标准。之后解释IaC的概念，并描述了相关的实践和有点，介绍了支持这些实践的不同类型的工具，并在IaC的背景下讨论了指令式和声明式编程范式。接着介绍IaC的核心机制之一状态调谐，最后深入研究了Kubernetes平台的细节，描述了它如何拥抱声明式并且使用持续调谐循环。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{声明式的通用Kubernetes调谐技术}\label{chapter_framework}
本文所陈述的声明式的通用Kubernetes Operator（即UniversalController，简称UC），主要是为了让开发者更容易的去实现以及部署Kubernetes Operators，进而扩展Kubernetes的API，而实现这一点的核心就是声明式Kubernetes调谐技术。

\section{问题分析}

Kubernetes Operator可以简单解释为自定义资源与自定义控制器的组合。自定义资源通过Kubernetes的CustomResourceDefinition机制可以很容易地添加，而自定义控制器需要开发者自行编写。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{pics/Operator-Principles.pdf}\\
  \caption{自定义控制器工作流程图}\label{fig:Operator-Principles}
\end{figure}

图\ref{fig:Operator-Principles}是自定义控制器的工作流程图，自定义控制器监视父子资源事件，调谐时根据父资源定义对子资源或相关资源进行增删改查，最后更新父资源状态。编写自定义控制器是编写代码来管理一个应用程序的生命周期的过程，开发一个自定义的控制器需要很多对Kubernetes的深入知识，而它们通常对大多数应用程序的生命周期管理是不需要的。除了应用程序生命周期的具体要求外，它还会给开发者带来管理负担，包括测试、升级、改变Operator的存储数据和改变API\cite{kudovscc}。

\subsection{现有的自定义控制器实现方式}

现有的自定义控制器实现方式主要有两种，一种基于Kubernetes客户端库，另一种基于controller-runtime库。

\subsubsection{Kubernetes Clients}

在开发控制器时，最自由的做法是使用现有的Kubernetes客户端，包括Go、Java、JS/Typescript或其他语言的客户端。这些客户端提供了对Kubernetes APIs的直接和底层的访问，没有任何包装或附加层。

\subsubsection{client-go}


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{pics/coding-operator.pdf}\\
  \caption{Operator编写流程}\label{fig:coding-operator}
\end{figure}

client-go是最常用也最成熟的客户端库，图\ref{fig:coding-operator}是使用client-go开发一个自定义控制器的基本流程，除了最后用于部署控制器的两步以外，各个流程都与图\ref{fig:client-go-controller-interaction}中的一个组件或者一个步骤对应。client-go相关代码以模版代码居多，在不同的控制器中，创建客户端、通知器、工作队列的代码都是高度相像的，只是需要处理的资源类型不同。每个控制器真正核心的部分都是``定义期望的状态（子资源们）''，即给出期望状态（state）。

如果用client-go来实现监视资源，需要先创建通知器工厂，再用工厂创建通知器，最后添加事件处理器，对资源的增加、更新、删除做出反应，如代码段\ref{listing:watch-foo-deploy}所示。代码段\ref{listing:watch-foo-deploy}的第5到10行的意思是，对于Foo资源，它的增加、更新和删除触发的事件处理器的工作都是把相关Foo资源的键加入工作队列等待处理，这是对父资源处理的一般惯例。对于Deployment资源，它的增加、更新和删除触发的事件处理器都调用handleObject方法。handleObject的简化版是代码段\ref{listing:watch-foo-deploy}的第22到27行，意思是根据Deployment的OwnerReference信息得到它的父资源Foo的命名空间和名称以定位，将这个父资源的键加入工作队列。这是对子资源处理的一般惯例。代码段\ref{listing:watch-foo-deploy}是典型的模版代码，不同的控制器都遵循这样的惯例，只是资源类型不同而已。


\begin{lstlisting}[language=Go,caption=sample-controller中监视Foo和Deployment的代码段,label=listing:watch-foo-deploy]
kubeInformerFactory := kubeinformers.NewSharedInformerFactory(kubeClient, time.Second*30)
exampleInformerFactory := informers.NewSharedInformerFactory(exampleClient, time.Second*30)
fooInformer := exampleInformerFactory.Samplecontroller().V1alpha1().Foos()
deploymentInformer := kubeInformerFactory.Apps().V1().Deployments()
fooInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
	AddFunc: controller.enqueueFoo,
	UpdateFunc: func(old, new interface{}) {
		controller.enqueueFoo(new)
	},
	DeleteFunc: controller.enqueueFoo,
})
deploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
	AddFunc: controller.handleObject,
	UpdateFunc: func(old, new interface{}) {
		newDepl := new.(*appsv1.Deployment)
		oldDepl := old.(*appsv1.Deployment)
		if newDepl.ResourceVersion == oldDepl.ResourceVersion { return }
		controller.handleObject(new)
	},
	DeleteFunc: controller.handleObject,
})
func (c *Controller) handleObject(obj interface{}) {
	if ownerRef := metav1.GetControllerOf(object); ownerRef != nil {
		if ownerRef.Kind != "Foo" { return }
		foo, err := c.foosLister.Foos(object.GetNamespace()).Get(ownerRef.Name)
		if err != nil { return }
		c.enqueueFoo(foo)
		return
	}
}
\end{lstlisting}

使用client-go实现调谐逻辑时，都需要开发者调用接口对资源进行增删改查。代码段\ref{listing:crud-rc}是用client-go编写时增删改查资源相关的代码。第1行获取本次调谐处理的Foo资源对象；第2行获取已经存在的子资源Deployment；第3到5行表示如果子资源还不存在，就创建它；第6到8行表示如果已存在的Deployment的replicas与Foo中的不一致，就更新它；第9行更新Foo的status。
\begin{lstlisting}[language=Go,caption=sample-controller中对资源进行增删改查的代码段,label=listing:crud-rc]
foo, err := c.foosLister.Foos(namespace).Get(name)
deployment, err := c.deploymentsLister.Deployments(foo.Namespace).Get(deploymentName)
if errors.IsNotFound(err) {
    deployment, err = c.kubeclientset.AppsV1().Deployments(foo.Namespace).Create(context.TODO(), newDeployment(foo), metav1.CreateOptions{})
}
if foo.Spec.Replicas != nil && *foo.Spec.Replicas != *deployment.Spec.Replicas {
    deployment, err = c.kubeclientset.AppsV1().Deployments(foo.Namespace).Update(context.TODO(), newDeployment(foo), metav1.UpdateOptions{})
}
_, err := c.sampleclientset.SamplecontrollerV1alpha1().Foos(foo.Namespace).Update(context.TODO(), fooCopy, metav1.UpdateOptions{})
\end{lstlisting}

\subsubsection{Kubernetes Controller Runtime}

正如上一节所讨论的，client-go库提供了许多抽象，可以简化Kubernetes控制器和状态调谐的实现。尽管如此，该库是为了成为一个通用的客户端而设计的，它并没有专门去解决编写控制器的很多问题。其他项目，如Operator SDK和Kubebuilder，提供了更高层次的抽象。它们专门针对希望扩展Kubernetes API的开发者，并考虑到自定义控制器的设计。它们都建立在一个共同的核心代码库之上，即controller-runtime\cite{k8s-sigs}。controller-runtime是一组库，共同代表了用自定义调谐逻辑扩展Kubernetes的通用模型\cite{controllerruntimedoc}\cite{k8s-sigs}。


\begin{lstlisting}[language=Go,caption=controller-runtime版sample-controller中监视Foo和Deployment的代码段,label=listing:watch-foo-deploy-cr]
c.Watch(&source.Kind{Type: &samplev1alpha1.Foo{}}, &handler.EnqueueRequestForObject{})
subresources := []runtime.Object{
    &appsv1.Deployment{},
}
for _, subresource := range subresources {
    c.Watch(&source.Kind{Type: subresource}, &handler.EnqueueRequestForOwner{
        IsController: true,
        OwnerType:    &samplev1alpha1.Foo{},
    })
}
\end{lstlisting}

借助controller-runtime以及代码生成工具，开发者可以省去很多模版代码的编写，但是开发者依然必须用Go语言来开发Operator项目，依然需要与Kubernetes的API打交道，需要自行处理更新策略，而且也不能规避所有的模版代码，因为判断实际状态和期望状态是否幂等、对资源进行创建或者更新依然是一套惯例代码样式。举例来说，代码段\ref{listing:watch-foo-deploy-cr}借助controller-runtime库设置监视。借助controller-runtime提供的高级接口，相比代码段\ref{listing:watch-foo-deploy}要精简的多，但依然要比YAML文件片段\ref{listing:declarative-watch}复杂，还要考虑到Go语言和controller-runtime接口的学习成本，所以使用依旧比较困难。

\subsection{小结}

在开发Kubernetes Operator时，开发者最关心也是最核心的部分就是调谐逻辑，但是为了实现一个完整的Operator，开发者不得不把大量的精力放在编写一些模版代码或者使用代码生成工具上，而且Kubernetes Operator的成熟开发工具都是用Go编写的，也是为Go项目服务的，对使用其他编程语言的开发者不友好。而为了使用这些工具，开发者也必须去学习Kubernetes API相关的深度知识，进而拉高了门槛。

本文的目的是简化Kubernetes Operators的开发、部署和管理，而通过声明式的通用Kubernetes调谐技术就能很好的做到这一点，接下来开始介绍。


\section{解决方法}

声明式的通用Kubernetes调谐技术的初衷十分简单：既然开发者实际只关心调谐逻辑，而其他与Kubernetes相关的代码基本都是模版代码或者有惯例可循，那么完全可以调谐逻辑的那部分代码代码单独抽取出来，提供一个接口供开发者实现，其他的代码都由系统或者框架代劳。该技术采用的方法是（1）封装编写自定义控制器的一般部分，例如资源监视、当前状态与期望状态对比、资源更新等；（2）将核心的自定义调谐逻辑单独抽取出来让开发者实现，并通过服务端应用实现声明式开发；（3）扩展Kubernetes的API，提供声明式接口，添加一种新的自定义资源，用于描述自定义控制器，自定义控制器通过该自定义资源动态定义，在运行时调用实际提供调谐逻辑的服务。该技术为开发者开发Operator提供一种简单的声明式方法，自定义资源和自定义控制器都借助Kubernetes的声明式API创建，让开发者将注意力完全集中在核心调谐逻辑上。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{pics/UniversalController-Workflow.pdf}\\
  \caption{UniversalController工作流程}\label{fig:UniversalController-Workflow}
\end{figure}

图\ref{fig:UniversalController-Workflow}是该技术的工作流程。其中监视资源以及为了向期望状态演进而对资源增删改查的操作都是由基于该技术实现的UC负责的，开发者只需要编写自定义调谐逻辑，计算并返回期望状态（state）与父资源状态（status）。借助声明式的通用Kubernetes调谐技术，一个Operator的开发流程会简化成如图\ref{fig:uc-coding-operator}所示。图\ref{fig:uc-coding-operator}中的Kubeless是一个serverless工具，用于将一个函数部署成一个网络服务。


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{pics/uc-coding-operator.pdf}\\
  \caption{借助UC实现一个Operator}\label{fig:uc-coding-operator}
\end{figure}

\section{声明式的通用调谐过程}\label{section:dur}
开发者编写自定义调谐逻辑时只需要在最后返回期望存在的资源，而不需要考虑如何通过与Kubernetes交互进行增删改查来确保它们的存在，编写过程本质上也是声明式的。

\subsection{自定义调谐逻辑}

Kubernetes中的调谐的工作本质上其实就是两个映射：
\begin{enumerate}
	\item 根据集群的当前状态（state）中相关部分得到父资源的状态（status）；
	\item 根据资源的规格对Kubernetes集群进行操作，一般是编排一些Kubernetes原生资源，例如Pods、Services等，来完成某个应用（例如数据库）的部署与维护。
\end{enumerate}

\begin{figure}[htbp]
  \centering
  \includegraphics[width= 0.8\textwidth]{pics/reconciler-interface.pdf}\\
  \caption{调谐逻辑}\label{fig:reconciler}
\end{figure}

图\ref{fig:reconciler}是一般的调谐逻辑抽象，它接受调谐请求和当前系统上下文，并返回调谐的结果。在Kubernetes中Domain APIs就是各种资源，包括Pod、Service、ReplicaSet等，开发者自定义的资源也包含在其中。在本文中，调谐请求就是当前被处理的资源对象，上下文就是通过标签筛选出的子资源以及相关资源，调谐结果是根据当前状态（state）得到该资源对象的状态（status）以及根据该资源对象的规格（specification）得到的期望子资源。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{pics/Foo-reconciliation.pdf}\\
  \caption{sample-controller的调谐过程}\label{fig:Foo-reconciliation}
\end{figure}

举例来说，\ref{section:sample-controller}节的sample-controller负责管理的自定义资源是Foo，它的spec中只有两个字段deploymentName和replicas，代表期望生成的Deployment资源的名称和指定的副本数量，它的status中只有一个字段availableReplicas，代表集群中实际可用的副本数量。图\ref{fig:Foo-reconciliation}展示了sample-controller的一次调谐过程。根据这个Foo的deploymentName和replicas会去生成一个名称为example-foo，副本数量为1的Deployment，这就是第二个映射，对应代码\ref{listing:sample-controller}的第17到41行的desiredDeployment函数。而根据当前集群中实际的Deployment的status中的availableReplicas字段可以得知可用的副本数量此刻为0，所以Foo的status的availableReplicas字段的值也要设置为0，这就是第一个映射，对应代码\ref{listing:sample-controller}的第10到13行。

现阶段自定义调谐逻辑需要以Webhook的形式提供，任何可以编写网络服务并处理JSON的编程语言都可以用于编写这段核心业务逻辑，实现了语言无关的特性。借助serverless工具，开发者实际需要编写的只是一个函数，其lambda表达式为(parent, children, related) => \{... return (status, children)\}。例如\ref{section:sample-controller}节的代码段\ref{listing:sample-controller}中的reconcile就是这样一个函数，最后只要返回调谐结果即可，不需要做任何增删改查之类的指令式操作。

\subsection{服务端应用（Server-side apply）}

基于声明式的通用Kubernetes调谐技术编写的自定义调谐逻辑不用去处理资源的增删改查，不用去与Kubernetes交互，只需要去返回期望状态（期望存在的资源集合）。服务端应用会去决定怎么到达期望状态。这个过程与开发者直接通过kubectl将资源描述文件提交给kube-apiserver很接近，指令式的操作极少，也是声明式的。服务端应用的逻辑与``kubectl apply''的逻辑接近，遵循惯例而不是配置，开发者不需要在CRD中提供如何合并旧资源与新资源的提示，自定义资源和原生资源都根据一套服务端应用逻辑得到合并结果。

\begin{lstlisting}[language=yaml,caption=一个Pod的定义文件,label=listing:pod-def]
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-app
spec:
  containers:
  - name: nginx
    image: nginx
\end{lstlisting}

举例来说，如果通过对YAML文件\ref{listing:pod-def}执行``kubectl apply -f''在Kubernetes中创建一个Pod，再用``kubectl get my-pod -o yaml''读取这个Pod，会看到很多YAML文件\ref{listing:pod-def}没有设置的额外字段都有了值。这些值是由kube-apiserver设置的默认值或者由控制器设置的特定值。当要对该Pod进行变更（例如添加一个标签）时，不需要对完整的Pod定义进行更改，只需要修改YAML文件\ref{listing:pod-def}，之后对更新后的YAML文件执行``kubectl apply -f''，这样只会更新变更的部分（也就是只添加一个标签），其余的部分都会保持不变。服务端应用对调谐逻辑返回的期望存在的子资源也是以相近的方法处理的，开发者实现的自定义调谐逻辑只需要返回包含必要字段的简短形式的资源定义，服务端应用会去决定这个资源对象需要被创建还是更新，以及在更新时哪些字段应该被变更，哪些应该保持不变。

\section{声明式接口}

UC CRD是本文提供的声明式API，通过CustomResourceDefinition注册在Kubernetes API中。通过创建一个UC资源，可以很方便的定制一种控制器，它根据父对象中指定的期望状态管理一组子对象，这也是最常见的控制器类型，像Deployment、StatefulSet、TFJob、PytorchJob的控制器都是符合这种模式的。UC CRD是对控制器的高级抽象，包含了一个控制器运行时需要知道的各项信息，例如事件配置、更新策略和调谐接口访问地址。开发者只需要填写好各项字段就能声明式地创建想要的控制器。UC CRD包含以下接口：

\begin{enumerate}
	\item \textbf{声明式的监视}：开发者只需要填写好parentResource对象和childResources对象数组，UC就会对这些资源进行监视，订阅它们的相关事件；
	\item \textbf{声明式的更新策略}：childResources对象数组中的每个childResource对象都有一个updateStrategy对象，通过设置它实现声明式的更新策略，支持OnDelete、Recreate、InPlace、 RollingRecreate、RollingInPlace；
	\item \textbf{声明式的调谐逻辑入口}：自定义调谐逻辑是唯一需要开发者编码实现的模块，开发者在这里只需要关心实际业务逻辑，开发完成后将其部署成一个web服务，将服务地址填入UC CRD的相应字段即可。如\ref{section:dur}节所介绍的那样，开发者在编码过程中只需要描述期望存在的资源即可，而不需要给出具体操作以确保它们的存在，这个过程本质上也是声明式的。
\end{enumerate}

\subsection{声明式的监视}

开发者不再需要为想监视的每一种类型的资源编写模板代码，而只要简单地列出这些资源的声明。YAML文本段\ref{listing:declarative-watch}说明该自定义控制器的父资源是Foo（foos是Foo在K8s中的复数表达），子资源是Deployment（deployments是Deployment在K8s中的复数表达）。系统自动为列出的资源建立监视流（watch stream），这些监视流被所有自定义控制器共享。开发者可以创建任意多的自定义控制器来观察Pod，而kube-apiserver只需要发送一个Pod监视流。UC就像一个解复用器，确定哪些控制器会关注流中的特定事件，并根据需要触发它们的事件处理器（一个函数）。
\begin{lstlisting}[language=yaml,caption=声明式的监视,label=listing:declarative-watch]
parentResource:
  apiVersion: njuics.cn/v1alpha1
  resource: foos
childResources:
- apiVersion: apps/v1
  resource: deployments
\end{lstlisting}


\subsection{声明式的更新策略}

一般的Operator在比较期望状态和实际状态后，会对资源进行更新，进行增删改查的操作。而不同的资源适合不同的更新策略，例如Pod一般会用重新创建，因为当一个Pod已经在Kubernetes中存在，它能修改的只有metadata中的标签（labels）和附加说明（annotations），spec中的字段都不能修改，如果需要修改，就只能删除重建。而Deployment除了名字和命名空间都可以修改，直接更新原资源即可。

在借助UC实现的自定义控制器中，UC会代为执行更新相关操作，为了适配各种类型的资源，内置了很多更新策略，通过声明式接口供开发者使用。Kubernetes的原生资源Deployment和StatefulSet都有对它们管理的Pod进行滚动更新的功能。UC内置的更新策略包括滚动更新类型的策略，开发者只需要在UC资源中填入相应字段就可以让自己的控制器拥有滚动更新的能力。例如，\ref{section:catset}节中的CatSet用例是在基于UC重写的StatefulSet，为其添加对滚动更新的支持，只需要YAML文件\ref{listing:catset-controller-config}中的第16到21行，也就是YAML文本段\ref{listing:declarative-rolling}中的第4到9行，表示对Pod更新采取滚动重写创建的策略。当Pods需要被更新时，每次按照指定的粒度重新创建一批，这一批的Pods的status中condition字段都包含片段\ref{listing:declarative-rolling}的第8到9行时（也就是都就绪时），才会去更新下一批。而为了让StatefulSet支持滚动更新，Kubernetes开发者改动了业务逻辑、模版文件、生成的代码，总共涉及到了超过9000行的改动\cite{statefulsetupdate}。

为StatefulSet添加滚动更新支持为Kubernetes引入了ControllerRevision的概念，用于对资源进行版本控制，保存滚动更新的中间信息，确保滚动更新被中断或者遭遇故障（例如控制器被删除重建）后可以恢复。UC也使用ControllerRevision对资源进行版本控制，以支持滚动更新，但存储的中间信息结构与StatefulSet有些差异，具体的会在\ref{section:rolling-control}节介绍。
\begin{lstlisting}[language=yaml,caption=添加滚动更新,label=listing:declarative-rolling]
   childResources:
   - apiVersion: v1
     resource: pods
+    updateStrategy:
+      method: RollingRecreate
+      statusChecks:
+        conditions:
+        - type: Ready
+          status: "True"
\end{lstlisting}

\section{小结}

本章首先对一个Opeator现有开发流程进行了介绍，然后在此基础之上总结其中存在的问题，之后提出声明式的调谐技术，致力于解决这些问题。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{声明式的通用Kubernetes Operator的设计与实现}\label{chapter_implement}

本文将实现了声明式通用Kubernetes调谐技术的工具称为UniversalController，简称UC。UC是一个声明式的通用Kubernetes Operator，其自身依然是一个传统的Operator，用Go语言编写完成。因为UC不能事先确定自己需要监视和处理的资源类型，所以使用了Kubernetes官方Go语言客户端client-go的dynamic包，它提供了动态的客户端，可以操作任意类型的资源，包括原生资源以及开发者自定义资源，这是它作为一个通用Operator的关键之一。

\section{总体架构}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{pics/uc-arch.pdf}\\
  \caption{UniversalController架构}\label{fig:uc-arch}
\end{figure}

图\ref{fig:uc-arch}展示了UC的总体架构。UC控制器是一个Kubernetes中的自定义控制器，负责监视UC CRD，当有一个新的UC CRD被创建时，它会建立对被声明的父资源与子资源建立监视流，同时启动父资源控制器（父资源控制器）作为响应。也就是说，UC是控制器的控制器，可以用于管理多个控制器，实现多控制器并存在一个进程中运行。父资源每次调谐都会去调用自定义调谐逻辑，向其发送当前状态相关信息，应用其返回的调谐结果。


\section{自定义控制器的抽象}
YAML代码\ref{listing:1}是UC CRD的定义，给出了一个新的CustomResourceDefinition，通过kubectl向kube-apiserver提交这个YAML文件就可以在Kubernetes中注册一种新的自定义资源类型以拓展Kubernetes API，之后就可以使用这个新的API提交资源定义来注册控制器。

YAML文件\ref{listing:catset-controller-config}是一个UC CRD资源的例子，定义了CatSet资源的控制器，它的行为几乎与Kubernetes原生资源的StatefulSet的控制器一致，是对StatefulSet的基于UC进行的二次实现。

\begin{lstlisting}[language=yaml,caption=UC CRD,label=listing:1]
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: "universalcontrollers.universalcontroller.njuics.cn"
spec:
  group: "universalcontroller.njuics.cn"
  names:
    kind: UniversalController
    listKind: UniversalControllerList
    plural: universalcontrollers
    singular: universalcontroller
  scope: Cluster
...
\end{lstlisting}

一个UC CRD的``spec''有五个字段：parentResource、childResources、resyncPeriodSeconds、generateSelector和hooks。parentResource的类型是ResourceRule，用于指定父资源类型，也就是这个控制器实际管理的资源。ResourceRule只有两个字段``APIVersion''和``Resource''，用于确定一种资源类型。childResources是一组ResourceRule，用于指定会被控制器生成的子资源类型。resyncPeriodSeconds被用于规定两次调谐之间间隔的时间，设置后下次调谐会在经过该时间后被执行。generateSelector是bool型的，如果为真，那么忽略父资源对象的标签选择器（如果存在的话），UC会为其生成独一无二的标签选择器，避免与其他的资源冲突。这里的标签选择器都是为了筛选子资源，符合标签选择器的子资源都会被当做父资源的子资源。hooks是一组定义了控制器行为的lambda hook。

\begin{lstlisting}[language=yaml,caption=作为UC CRD示例的catset-controller,label=listing:catset-controller-config]
apiVersion: universalcontroller.njuics.cn/v1alpha1
kind: UniversalController
metadata:
  name: catset-controller
spec:
  parentResource:
    apiVersion: mlhub.njuics.cn/v1alpha1
    resource: catsets
    revisionHistory:
      fieldPaths:
        - spec.template
  childResources:
    - apiVersion: v1
      resource: pods
      updateStrategy:
        method: RollingRecreate
        statusChecks:
          conditions:
            - type: Ready
              status: "True"
    - apiVersion: v1
      resource: persistentvolumeclaims
  hooks:
    sync:
      webhook:
        url: "http://catset-controller.universalcontroller:8080"
    finalize:
      webhook:
        url: "http://catset-controller.universalcontroller:8080"
\end{lstlisting}


\section{动态类型高级操作接口实现}

Kubernetes的官方Go语言客户端库client-go，提供了dynamic模块，可以用于创建动态客户端，借助于动态客户端，只要知道资源的apiVersion和Kind，就可以对任意一种资源进行操作。UC基于此，实现了支持动态资源类型的informer和indexer，用于订阅特定资源相关事件以及查找特定类型的资源，是自定义控制器的核心组件。声明式的监视和服务端应用都依赖于动态类型高级操作接口。


\begin{lstlisting}[language=Go,caption=客户端实现,label=listing:client]
type Clientset struct {
	config    rest.Config
	resources *dynamicdiscovery.ResourceMap
	dc        dynamic.Interface
}
type ResourceClient struct {
	dynamic.ResourceInterface
	*dynamicdiscovery.APIResource
	rootClient dynamic.NamespaceableResourceInterface
}
func New(config *rest.Config, resources *dynamicdiscovery.ResourceMap) (*Clientset, error)
func (cs *Clientset) Resource(apiVersion, resource string) (*ResourceClient, error)
func (cs *Clientset) resource(apiResource *dynamicdiscovery.APIResource) *ResourceClient {
	client := cs.dc.Resource(apiResource.GroupVersionResource())
	return &ResourceClient{ ResourceInterface: client, APIResource: apiResource, rootClient: client, }
}
func (rc *ResourceClient) AtomicUpdate(orig *unstructured.Unstructured, update func(obj *unstructured.Unstructured) bool) (result *unstructured.Unstructured, err error)

type Unstructured struct {
	Object map[string]interface{}
}
\end{lstlisting}

代码段\ref{listing:client}是客户端的结构体和一些方法，UC首先需要用New方法得到一个Clientset类型的对象，对于各种资源，只要知道资源的apiVersion和kind并且该资源在K8s中实际存在，都可以用这个对象的Resource方法得到一个ResourceClient对象，该对象可以对这类资源进行各类CURD的操作，所有的资源都以Unstructured类型存储，Unstructured中只有一个字典类型的字段，实际是把资源以接近JSON的形式存储起来。

代码段\ref{listing:informer}展示了如何在client的基础之上实现informer，informer会调用client的List和Watch方法来监视资源。SharedInformer的作用是让在一个进程中运行的控制器们共享订阅，避免重复订阅浪费内存和网络带宽。如果需要监视一个新资源，会创建一个新的SharedInformer，封装为ResourceInformer以供使用；如果这个资源已经被监视，则返回的ResourceInformer会复用之前创建的SharedInformer。用一个字典存储资源类型到负责监视该类型的SharedInformer的映射，

\begin{lstlisting}[language=Go,caption=通知器（Informer）实现,label=listing:informer]
type sharedResourceInformer struct {
	informer cache.SharedIndexInformer
	lister   dynamiclister.Lister
	defaultResyncPeriod time.Duration
	eventHandlers *sharedEventHandler
	close func()
}
func newSharedResourceInformer(client *dynamicclientset.ResourceClient, defaultResyncPeriod time.Duration, close func()) *sharedResourceInformer {
	informer := cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
				return client.List(opts)
			},
			WatchFunc: client.Watch,
		}, &unstructured.Unstructured{}, defaultResyncPeriod,
		cache.Indexers{ cache.NamespaceIndex: cache.MetaNamespaceIndexFunc, },
	)
	sri := &sharedResourceInformer{
		close:               close,
		informer:            informer,
		defaultResyncPeriod: defaultResyncPeriod,
		lister: dynamiclister.New(informer.GetIndexer(), client.GroupVersionResource()),
	}
	sri.eventHandlers = newSharedEventHandler(sri.lister, defaultResyncPeriod)
	informer.AddEventHandler(sri.eventHandlers)
	return sri
}
type ResourceInformer struct {
	sharedResourceInformer *sharedResourceInformer
	informerWrapper        *informerWrapper
}
func newResourceInformer(sri *sharedResourceInformer) *ResourceInformer
\end{lstlisting}




\section{Webhooks}

编写自定义调谐逻辑是开发者基于UC开发Operator时唯一需要的代码编写工作。编写完成后需要以webhook的形式将其发布出来，之后在UC CRD的相应字段填写服务地址就完成了自定义控制器的配置。这是实现声明式调谐的关键之一，另一个关键是下一节的服务端应用。在示例的YAML文件\ref{listing:catset-controller-config}中hooks.sync就定义了当前控制器使用的自定义调谐逻辑的服务入口。UC CRD中的Webhook结构如表\ref{table:webhook}所示。在webhook中，service的结构如表\ref{table:service-reference}所示。

\begin{table}
  \centering
  \begin{tabular}{ccp{50mm}}
    \toprule
    \textbf{字段} & \textbf{Go类型} & \textbf{说明} \\
    \midrule
    url  & string  & 完整的url地址，优先级比path和service的组合高\\
    timeout  & Duration   &  时限，过期未收到回复就是请求超时 \\
    path     & string  &  请求链接的后缀 \\
    service    & ServiceReference   &  应该被发送请求的K8s Service \\
    \bottomrule
  \end{tabular}
  \caption{Webhook}\label{table:webhook}
\end{table}

\begin{table}
  \centering
  \begin{tabular}{ccp{50mm}}
    \toprule
    \textbf{字段} & \textbf{Go类型} & \textbf{说明} \\
    \midrule
    name  & string  & 该Service的名称\\
    namespace  & string   &  该Service的命名空间 \\
    port     & int32  & 该Service提供服务的接口 \\
    protocol    & string   &  协议，默认为http \\
    \bottomrule
  \end{tabular}
  \caption{Service Reference}\label{table:service-reference}
\end{table}

在UC CRD的spec中，hooks字段有以下三个子字段：sync、finalize和customize。sync用于指定如何调用同步钩子，finalize用于指定如何调用收尾（finalize）钩子，customize用于指定如何调用Customize钩子，它们都对应了一种钩子类型，下面开始分别介绍。

\subsection{同步钩子}

同步钩子被用来指定为给定的父资源创建或维护那些子资源，即期望状态（state）。根据UC CRD的spec，UC会收集所有需要的资源，并向同步钩子发送最新观察到的状态（state）。同步钩子返回期望状态后，UC会开始通过一系列操作向它收敛，操作包括创建、删除和更新资源对象。

可以简单的把同步钩子看做一个脚本，它生成json发送到``server-side apply''，同时，与一次性的客户端生成器不同的是，这个脚本可以观察到集群中最新的状态（state），并且会在观察到的状态（state）发生变化时自动被执行。

\paragraph{（1）同步钩子请求}
一个请求中只会包含一个父资源，所以同步钩子一次只需要考虑一个父资源。请求体是一个JSON对象，它的字段包括parent、children、related和finalizing。parent对象是一个json形式的父资源，和用kubectl get <parent-resource> <parent-name> -o json得到的结果一样。children对象存储了与父资源相关的子资源们，是通过标签选择器筛选得到的。related对象只有当Customize钩子存在时，会存储相关资源，否则为空。finalizing是布尔型的，在调用同步钩子是始终为false。

children对象的每个字段都代表UC CRD的spec中指定的子资源类型之一。每个子资源类型的字段名是<kind>.<apiVersion>。举例来说，Pods的字段名是Pod.v1，而StatefulSets的字段名是StatefulSet.apps/v1。在每个字段中（例如在children['Pod.v1']中），存储着一个字典，它的键是当前资源标识，它的值是该资源的json表示。如果父资源和子资源的作用域相同（都是集群的或者都是命名空间的），那么键就只是子资源的名称，如果父资源是集群作用域，而子资源是命名空间作用域，那么键的形式是{.metadata.namespace}/{.metadata.name}。这是为了区分可能存在的在不同命名空间的两个同名子资源。父资源是命名空间作用域而子资源是集群作用域的情况不可能出现。举例来说，如果父资源在my-namespace命名空间下，那么在my-namespace命名空间下的一个名称为my-pod的Pod会被存储在request.children['Pod.v1']['my-pod']。如果父资源是集群作用域的，这个Pod会被存储在request.children['Pod.v1']['my-namespace/my-pod']。如果在同步时没有观察到某个类型的子资源，那么该类型的键依然存在，值为空对象。例如，如果Pod是子资源类型之一，但没有任何现有的Pods资源与父资源的选择器相匹配，请求体的形式是代码\ref{listing:children-pod}，而不是代码\ref{listing:children}。
\begin{lstlisting}[language=json,caption=请求体,label=listing:children-pod]
{
  "children": {
    "Pod.v1": {}
  }
}
\end{lstlisting}

related字段下存储着相关资源对象，格式与children字段下的对象相同，表示与给定父资源的Customize钩子响应相匹配的资源，这些资源不由父资源控制器管理，因此不可修改，但可以将它们当做系统上下文，进而得到子资源的期望配置。当观察到相关资源被更新时，就算父资源和子资源都没有变化，同步钩子也会被触发。


\begin{lstlisting}[language=json,caption=异常请求体,label=listing:children]
{
  "children": {}
}
\end{lstlisting}

\paragraph{（2）同步钩子响应}
同步钩子的响应体的字段包括status、children和resyncAfterSeconds。status是一个JSON对象，将完全取代父资源中的status字段。children是一组JSON对象组成的列表，代表所有期望存在的子资源。resyncAfterSeconds是下次同步的时间间隔，以秒为单位，类型是浮点数。

状态（status）的设置完全由开发者提供的调谐逻辑决定，状态（status）应该根据最后观察到的状态（state）来填写，是一个当前值，而不是期望值。响应体中的children字段是一个对象列表，而不是请求体中那样的字典，每一个对象都是一个期望存在的子资源。UC按照类型和名称对发送的对象进行分组，以方便开发者简化脚本，但实际上这是多余的，因为每个对象都包含自己的apiVersion、kind和metadata.name。

开发者应该把响应体中的每个子资源看作是被发送到``kubectl apply''，只需要设置开发者关心的字段。调谐逻辑不应该直接把请求中的子资源复制到返回结果中，返回的结果应该完全根据父资源的specification和系统上下文重新生成。如果一个子资源在请求体中存在，而调谐逻辑拒绝在响应体中返回它，那么它会被UC在收到响应后删除。

如果返回的resyncAfterSeconds被设置为一个大于0的值，同步钩子在延迟一段时间后会被再次调用，请求体中的parent字段的值依然是这个特定的父资源，其他字段依据父资源设置。这个设置时一次性的，不会周期性重新同步，而且只针对这个特定的父资源。

\subsection{Finalize钩子}
如果定义了finalize钩子，UC将为父资源添加一个finalizer，这将防止父资源被直接删除，而是直到finilize钩子执行完，并且钩子的响应表明清理已经完成，它才能真正的被删除。如果没有定义finalize钩子，那么当一个父对象被删除时，垃圾回收器会立即删除所有的子对象，而不会调用任何钩子。finalize钩子的语义大多与同步钩子的语义相当。当父资源正在被删除且需要清理时，父资源控制器在调谐时会调用finalize钩子而不是同步钩子。UC将尝试调谐在children字段中返回的期望状态（state），并将在父资源上设置状态（status）。当观察到的状态发生变化时，UC可能会多次调用finalize钩子，甚至可能是在一次表明已经完成finalize的调用之后进行调用。开发者编写的处理程序在确定清理已经完成，无需进行更多操作时，即可报告成功。

同步钩子和finalize钩子都有一个叫做finalizing的请求字段，在同步钩子请求中始终为false，在finalize钩子请求中始终为true。这让开发者可以自己选择将finalize钩子作为一个单独的处理程序还是作为同步处理程序中的一个分支来实现。要为两者使用相同的处理程序，只需将finalize钩子设置为与同步钩子相同的值。

\paragraph{（1）finalize钩子请求}
finalize钩子的请求体格式与同步钩子的完全相同，只是finalizing字段始终为true。如果同步钩子和finalize钩子共享同一段处理程序，可以使用finalizing字段来判断本次调谐应该该清理还是进行正常的同步。如果为finalize定义了一个单独的处理程序，就不需要检查finalizing字段，因为它总是为真。

\paragraph{（2）finalize钩子响应}
finalize钩子响应体拥有所有同步钩子响应体的字段，但还有一个额外的字段finalized，是一个布尔值，用于表示清理是否已经完成。

\subsection{Customize钩子}

如果定义了Customize钩子，UC会询问它哪些资源是相关资源，应该放入同步钩子和finalize钩子的请求中，这在有些场景下非常有用。例如，开发者想实现一个控制器将指定的ConfigMaps复制到每个Namespace中，那么在调谐时需要知道有哪些Namespaces。如果没有定义Customize钩子，那么同步钩子和finalize钩子的请求体中related字段的值都是空的。当前Customize钩子的请求体中不会提供任何关于集群当前状态（state）的信息，只包含父资源，选择器会根据父资源的定义生成，之后用它筛选得到相关对象的集合。

\paragraph{（1）Customize钩子请求}
Customize钩子的请求体只有一个字段parent，用于存储一个父资源的json表示。
\paragraph{（2）Customize钩子响应}
Customize钩子的响应体只有一个字段relatedResources，存放了一组JSON对象，每个JSON对象是一个ResourceRule，用于筛选资源。ResourceRule的字段包括apiVersion、resource、labelSelector、namespace和name。apiVersion和resource不能为空，resource是资源的小写名称，例如deployments, replicasets, statefulsets。labelSelector是用于筛选资源的标签选择器，如果为空，用namespace和names字段去定位资源。namespace是选填项，指资源所在的命名空间。name也是选填项，代表资源名称列表。如果设置了labelSelector，namspace字段和name字段就应该都为空，反之亦然。它们不应该被同时设置，它们代表了两种不同的资源筛选方式，在一次筛选中只能使用一种。UC收到Customize钩子响应后就会去用这一系列资源筛选规则找到符合条件的资源们，并放入同步或finalize钩子的请求体中。

\section{服务端应用}

开发者实现的自定义调谐逻辑只需要返回包含必要字段的资源定义，服务端应用会去决定这个资源对象需要被创建还是更新，以及在更新时哪些字段应该被变更，哪些应该保持不变。判断是否需要创建一个资源十分简单：当这个资源不存在时就去创建。当资源已经存在时就需要先合并旧资源（已有资源）和新资源（调谐逻辑返回结果中包含的资源），再判断是否需要更新它，情况就会复杂一些，具体逻辑如下：

\begin{enumerate}
	\item 如果一个字段在旧资源中被设置，在新资源中没有被设置，就取旧资源的值；
	\item 如果一个字段在旧资源中没有被设置，在新资源中被设置，就取新资源的值；
	\item 如果一个字段在旧资源和新资源中都被设置，就取这两个值的合并结果。
\end{enumerate}

如果在新旧资源中都被设置的字段的值类型是字典，复用以上逻辑合并即可；如果是列表，需要做特殊处理。对于列表，首先要检测这个列表是否是``关联列表''，如果不是，用新值替换旧值；如果是，进行合并操作。关联列表是一个对象的列表，它应该被视为字段一样处理，但由于JSON/YAML的限制，它在序列化后看起来与有序列表一样。对于原生资源，``kubectl apply''通过配置来确定哪些列表是关联列表，对如何处理它们每个字段进行硬编码，但是目前还没有机制让CRD指定这种列表处理方式，所以kubectl apply假设所有的列表都是``原子（atomic）''的，不应该被合并，只能完全替换。服务端应用遵循约定（convention）而不是配置：只要CRD满足约定条件，它的一些字段就应该当做关联列表来处理。具体来说，当且仅当满足以下所有条件时，一个列表被检测为一个关联列表。

\begin{enumerate}
	\item 列表中的所有项都是JSON对象（不是标量，也不是其他列表）；
	\item 列表中的所有JSON对象都有一些共同的字段名，且该字段名是常见的合并键之一（最常见的是name）。
\end{enumerate}

如果一个列表被检测为一个关联列表，那么所有对象共有的常见字段名（例如name）被用作合并键。如果共有的常见字段名超过一个，根据事先设置的字段优先级表，选择优先级最高的那个。这使得UC不需要预先了解它所处理的资源就能做出相应的处理。


\section{控制器实现}

图\ref{fig:uc-arch}中的UC控制器和父资源控制器都是自定义控制器。图\ref{fig:client-go-controller-interaction}展现了一个自定义控制器的工作方式。UC控制器和父资源控制器都使用这种经典控制器模式。UC控制器是监视资源与服务端应用的实际执行者，父资源控制器则被UC控制器委托去调用实际提供调谐逻辑的服务。

UC控制器监视着UC类型的资源，提供了UC相关的服务，同时管理着通过UC CRD创建的自定义控制器。它的``Handle Object''部分确保集群状态与UC CRD期望的一致，也就是保持所有注册的自定义控制器正确运行。UC控制器同时监视着通过UC CRD声明的所有父资源与子资源，将资源相关事件分发给各个父资源控制器，只要父资源控制器对应的UC CRD中包含了某个资源类型，父资源控制器就会收到该类型资源的事件。

父资源控制器的``Handle Object部分''是开发者自定义的代码段，一般是若干个函数。当开发者使用UC的声明式API创建控制器时，开发者需要提供的函数中只包含当前控制器所特有的业务逻辑。这些函数会通过webhook调用，所以开发者可以用任何能够处理网络请求和JSON的编程语言来编写这些函数。

父资源控制器会执行一个调谐循环，在调谐时调用开发者提供的函数，之后再决定做什么。UC为每一个父资源控制器预先准备了调谐循环的通用逻辑，开发者不需要借助代码生成器，可以完全将精力集中在编写调谐函数上。现阶段UC接受的调谐器是Webhook形式的，开发者可以借助serverless工具，例如kubeless或者openFaas，将函数发布成一个Web服务，再提供给控制器。借助UC的API和serverless就可以使开发工作完全集中于业务逻辑，免去了很多琐碎的工作和模版代码。


接下来介绍UC控制器和父资源控制器的``Handle Object''分别是怎么实现的。

\subsection{UC CRD资源同步流程}

\begin{algorithm}[H]
\small
\DontPrintSemicolon
  \KwInput{UC CRD}
  \KwOutput{父资源控制器（PC）}
  \If{PC exists}
    {
        \If{UC CRD’s spec equals PC.UC’s spec}
        {Terminate}
       	\Else
       	{
          Stop the existing PC\\
          Delete the existing PC in the map
        }
    }
  \Else
  {
    Create a new PC and start it\\
    Save the new PC in the map   
  } 
\caption{同步UC CRD}
\label{algorithm:sync-uc}
\end{algorithm}

算法\ref{algorithm:sync-uc}根据当前的UC CRD资源定义进行调谐，如果这个资源对应的控制器已经存在，并且不需要修改，spec完全一致，那么不用做任何事，本次调谐结束，否则就删除旧的控制器。接下来新建父资源控制器，并启动，和一般的controller-mananger模式中一样，这个父资源控制器运行在一个新的Go协程中，只是此时UC控制器承担了manager的职责，所以UC控制器是controller-controller。

\subsection{同步父资源（Parent Resource）}


代码段\ref{listing:syncparent}展示了父资源控制器对父资源的同步过程：
\begin{enumerate}
	\item claimChildren方法会通过标签选择器找到所有的已经存在的子资源；
	\item 如果Customize钩子非空，通过Customize钩子找到相关资源；
	\item 将父资源、已经存在的子资源、相关资源放入同步钩子请求体中，调用同步钩子，得到调谐结果，其中包含需要设置的父资源状态（status）和期望存在的子资源；
	\item 先比较已经存在的子资源和期望的子资源，如果一个资源已经存在，但是与期望不一致，就把它们两个当做JSON对象合并，之后根据更新策略更新得到合并结果；如果一个期望的资源还不存在，就创建它，其实就是执行了服务端应用；
	\item 最后更新父资源状态。
\end{enumerate}

\section{更新策略}
\subsection{更新策略介绍}
UC提供了很多更新策略，开发者可以通过声明式接口使用它们，而不用写任何代码。现有的5种更新策略如下：
\begin{enumerate}
	\item 待删除后更新（OnDelete）：不更新现有的子资源，直到它被其他的客户端（例如kubectl）删除；
	\item 立刻重建（ReCreate）：立即删除任何不符合期望状态的子资源，并根据期望状态重新创建；
	\item 就地更新（InPlace）：立刻就地更新任何不符合期望状态的子资源；
	\item 滚动重建（RollingRecreate）：每次调谐删除一个与期望状态不同的子资源，并在处理下一个子资源之前根据期望状态重建它。在任意时刻，如果已经更新的子资源中有一个或多个状态检查失败，则暂停滚动更新；
	\item 滚动就地更新（RollingInPlace）：每次就地更新一个与期望状态不同的子资源。如果已经更新的子资源中有一个或多个状态检查失败，则暂停滚动更新。
\end{enumerate}

\begin{lstlisting}[language=Go,caption=同步父资源,label=listing:syncparent]
func (pc *parentController) syncParentObject(parent *unstructured.Unstructured) error {
	observedChildren, err := pc.claimChildren(parent)
	relatedObjects, err := pc.customize.GetRelatedObjects(parent)
	syncResult, err := pc.syncRevisions(parent, observedChildren, relatedObjects)
	desiredChildren := common.MakeChildMap(parent, syncResult.Children)
	if syncResult.ResyncAfterSeconds > 0 {
		pc.enqueueParentObjectAfter(parent, time.Duration(syncResult.ResyncAfterSeconds*float64(time.Second)))
	}
	if parent.GetDeletionTimestamp() == nil || pc.finalizer.ShouldFinalize(parent) {
		common.ManageChildren(pc.dynClient, pc.updateStrategy, parent, observedChildren, desiredChildren)
	}
	pc.updateParentStatus(parent, syncResult.Status)
	return err
}
\end{lstlisting}

不同的资源适合不同的更新策略，例如Pod一般会用ReCreate或者RollingRecreate，因为对于一个已经在Kubernetes中存在的Pod，它能修改的只有metadata中的标签（labels）和附加说明（annotations），spec中的字段都不能修改，如果需要修改，就只能删除重建。而Deployment除了名字和命名空间都可以修改，用InPlace或者RollingInPlace显然更合适。

\subsection{滚动更新版本控制}\label{section:rolling-control}
ControllerRevision是UC使用的一个内部API，用于实现声明式的滚动更新，主要受到Kubernetes原生资源StatefulSet和DaemonSet使用的ControllerRevision启发后实现。


每个ControllerRevision都与一个资源相关，名称是该资源的类型、资源所在的apiGroup以及版本后缀组成的。版本后缀是对该资源指定字段的哈希结果。默认情况下，一旦一个特定的父资源被删除，属于该资源的ControllerRevision们会被垃圾回收处理掉，但是也可以在父资源的删除过程中抛弃ControllerRevision，不再与这个父资源有关系的ControllerRevision也就不会被删除了，就可以创建另一个父资源来接管它。接管的规则基于父资源的标签选择器，和ReplicaSet接管Pods的方式一样。

\begin{lstlisting}[language=yaml,caption=ControllerRevision示例,label=listing:controllerrevision]
apiVersion: universalcontroller.njuics.cn/v1alpha1
kind: ControllerRevision
metadata:
  name: catsets.universalcontroller.njuics.cn-5463ba99b804a121d35d14a5ab74546d1e8ba953
  labels:
    app: nginx
    component: backend
    universalcontroller.njuics.cn/apiGroup: universalcontroller.njuics.cn
    universalcontroller.njuics.cn/resource: catsets
parentPatch:
  spec:
    template:
      [...]
children:
- apiGroup: ""
  kind: Pod
  names:
  - nginx-backend-0
  - nginx-backend-1
  - nginx-backend-2
\end{lstlisting}

YAML文件\ref{listing:controllerrevision}是ControllerRevision的一个例子，parentPatch字段存储了父资源的部分表示，它只包含UC CRD的revisionHistory字段列出的那些参与滚动更新的字段，默认是spec。例如，如果一个UC CRD的revisionHistory是数组[``spec.template'']，那么parentPath只会包含spec.template和嵌套在其中的子字段。这样就可以在滚动更新的过程中做出选择性行为。任何不属于revisionHistory的字段如果被更新，更新都会立即生效，而不是进行滚动更新。


children字段存储了一个``属于''这个ControllerRevison的子资源列表，UC就是通过这个字段跟踪一个子资源属于哪个ControllerRevision。children字段的值是按照apiGroup和kind进行分组的。对于每个apiGroup和kind的组合，存储了一个对象名称列表。在滚动更新过程中，如果一个还没有更新的Pod被开发者通过kubectl删除了，那么它应该重建它被删除之前的版本，而不是最新版本，以保证滚动更新的次序不被打乱。

当UC决定将一个子资源更新到另一个版本时。它首先会更新相关的ControllerRevison来表达这个意图，这些更新被提交后，它就会根据所配置的子资源更新策略开始更新该子资源。这确保了滚动更新的中间结果在kube-apiserver中被持久化，就算UC重启，也能从之前中断的位置继续更新。


\section{小结}
本章详细介绍了各个组件或功能在UniversalController中是设计与实现的，涉及到了各方面的细节。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{实验评估}\label{chapter_experiments}

本章基于UC重新实现了一些现有的Operators，并进行了内存和网络方面的性能测试。

\section{用例1：重新实现sample-controller}\label{section:sample-controller}
\subsection{介绍}
sample-controller是Kubernetes官方提供的一个Operator编写样例，项目地址是https://github.com/kubernetes/sample-controller。它是一个简单的控制器，监视通过CustomResourceDefinition添加的Foo资源，为每个Foo保证一个对应的Deployment存在。sample-controller展示了一个标准的Operator是如何实现并工作的，使用client-go与kube-apiserver交互，编写控制器的各个组件，没有使用更高级的抽象包。

\subsection{实现}

首先要填写sample-controller的UC CRD。sample-controller的父资源的apiVersion是njuics.cn/v1alpha1，resource是foos。子资源只有一种，apiVersion是apps/v1，resource是deployments，更新策略选择InPlace。hooks.sync.webhook.url设为``http://sample-controller.universalcontroller:8080''，它是调谐逻辑的入口。

JavaScript代码\ref{listing:sample-controller}就是所有需要写的代码，而不是一个代码段。它的逻辑很简单，从请求体中取出Foo资源，根据它的定义生成期望的Deployment，Foo资源的status只有一个字段表示可用的副本数，如果Deployment还不存在，可用副本数设为0，否则就将其设置为该Deployment的status.availableReplicas的值，最后将status和Deployment返回即可。

接下来借助kubeless将这个函数部署成web服务，只需要一条命令
``kubeless -n universalcontroller function deploy sample-controller --runtime nodejs10 --from-file sync.js --handler sync.handler''。之后在universalcontroller命名空间下会生成一个名叫sample-controller的Service资源和一个名叫sample-controller的Deployment资源，于是在集群内部就可以用http://sample-controller.universalcontroller:8080访问这个服务，这个url就是要生成的自定义控制器使用的同步钩子。最后使用``kubectl apply''命令提交定义控制器的UC CRD完成控制器的注册。

\begin{lstlisting}[language=JavaScript,caption=sample-controller的实现代码,label=listing:sample-controller]
module.exports =  {
  handler: (event, context) => { let observed = event['data']; return reconcile(observed.parent, observed.children);} };

var reconcile = function (foo, children) {
    let desiredChildren = [];
    let currentStatus = {};
    let allDeploys = children['Deployment.apps/v1'];
    let fooDeploy = allDeploys ? allDeploys[foo.spec.deploymentName] : null;
    let replicas = fooDeploy ? fooDeploy.status.availableReplicas : 0;
    currentStatus = {availableReplicas: replicas};// Set the status of Foo
    desiredChildren = [desiredDeployment(foo)];
    return {status: currentStatus, children: desiredChildren};
}
var desiredDeployment = function (foo) {
  let deploy = {
    apiVersion: "apps/v1",
    kind: "Deployment",
    metadata: {
      name: foo.spec.deploymentName,
      namespace: foo.metadata.namespace,
    },
    spec: {
      replicas: foo.spec.replicas,
      template: 
      	[...]
    }
  };
  return deploy;
};
\end{lstlisting}


\section{用例2：重新实现tf-operaotr}
\subsection{介绍}
tf-operator由kubeflow社区开发，项目地址为https://github.com/kubeflow/tf-operator，它提供了TFJob这个自定义资源，使用户能够轻松地在Kubernetes上运行分布式或单机TensorFlow任务。如图\ref{fig:tfjobtrans}所示，它的控制器会自行编排Pod和Service资源来实现各个训练节点的启动以及它们之间的通信。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{pics/tfjobtrans.png}\\
  \caption{TFJob的编排}\label{fig:tfjobtrans}
\end{figure}

\subsection{实现}

首先要填写TFJob控制器的UC CRD。TFJob控制器的父资源的apiVersion是mlhub.njuics.cn/v1alpha1，resource是tjobs。子资源有两种，第一种的apiVersion是v1，resource是services，更新策略选择InPlace；第二种的apiVersion是v1，resource是pods，更新策略是ReCreate。hooks.sync.webhook.url设为``http://tensorflow-controller.universalcontroller:8080''，是调谐逻辑的入口。


\begin{algorithm}[H]
\small
\DontPrintSemicolon
  \KwInput{tfjob,observedPods}
  \KwOutput{tfjob status,desiredChildren}
  \For{replicaType in tfjobs.replicas’s keys}
  {
  	Filter pods in obervedPods with replicaType\\
  	Calculate the number of active pods，succeeded pods and failed pods\\
  	Generate the definition of tfjob.spec.replicas services and tfjob.spec.replicas pods
  }
\caption{tf-operator内部逻辑}
\label{algorithm:tf-operator}
\end{algorithm}


tf-operator依然用JavaScript实现，但实现逻辑相当复杂，总代码行数为408行，原版tf-operator中的逻辑都转译了过来。算法\ref{algorithm:tf-operator}是tf-operator的内部逻辑，包括根据不同的副本类型使用当前tfjob资源中相应的模版来创建Pod，为每一个Pod创建一个Service，为每个副本类型分别统计每种状态的副本的数量来更新tfjob的status等。

接下来借助kubeless将这个函数部署成web服务，部署命令为：

kubeless -n universalcontroller function deploy tensorflow-controller --runtime nodejs10 --from-file sync1.js --handler sync1.handler

之后在universalcontroller命名空间下会生成一个名叫tensorflow-controller的Service资源和一个名叫tensorflow-controller的Deployment资源，于是在集群内部就可以用http://tensorflow-controller.universalcontroller:8080访问这个服务，这个url就是要生成的controller使用的同步钩子。

\section{用例3：CatSet与滚动更新}\label{section:catset}
\subsection{介绍}
CatSet是对Kubernetes原生资源StatefulSet的重新实现，可以展示滚动更新的使用。
\subsection{实现}

YAML文件\ref{listing:catset-controller-config}是catset-controller的声明式定义。CatSet的spec结构与StatefulSet的spec结构完全一样。

%\newpage
%\begin{lstlisting}[language=yaml,caption=CatSet资源示例,label=listing:catset-sample]
%apiVersion: mlhub.njuics.cn/v1alpha1
%kind: CatSet
%metadata:
%  name: nginx-backend
%spec:
%  serviceName: nginx-backend
%  replicas: 3
%  selector:
%    matchLabels:
%      app: nginx
%  template:
%    metadata:
%      labels:
%        app: nginx
%        component: backend
%    spec:
%      terminationGracePeriodSeconds: 1
%      containers:
%      - name: nginx
%        image: gcr.io/google_containers/nginx-slim:0.8
%        ports:
%        - containerPort: 80
%          name: web
%        volumeMounts:
%        - name: www
%          mountPath: /usr/share/nginx/html
%  volumeClaimTemplates:
%  - metadata:
%      name: www
%      labels:
%        app: nginx
%        component: backend
%    spec:
%      accessModes: [ "ReadWriteOnce" ]
%      resources:
%        requests:
%          storage: 1Gi
%\end{lstlisting}


CatSet的控制器依然用JavaScript实现，期望存在的Pods和PVC（如果有的话）是带编号的，代码\ref{listing:catset-1}为已经存在的Pods根据编号建索引。代码\ref{listing:catset-3}，统计已经就绪的Pods数量，设置CatSet的status，包括当前副本数量（replicas）和就绪副本数量（readyReplicas）。

\begin{lstlisting}[language=JavaScript,caption=为已存在的Pods建索引,label=listing:catset-1,gobble=4]
    if (observed.children && observed.children['Pod.v1']) {
      for (let pod of Object.values(observed.children['Pod.v1'])) {
        let ordinal = getOrdinal(catset.metadata.name, pod.metadata.name);
        if (ordinal >= 0) observedPods[ordinal] = pod;
      }
    }
\end{lstlisting}

\newpage
\begin{lstlisting}[language=JavaScript,caption=删除后清理,label=listing:catset-2,gobble=4]
    if (observed.finalizing) {
      catset.spec.replicas = 0;
      finalized = (Object.keys(observedPods).length === 0);
    }
\end{lstlisting}

\begin{lstlisting}[language=JavaScript,caption=设置当前状态（status）,label=listing:catset-3,gobble=4]
    for (var ready = 0; ready < catset.spec.replicas && isRunningAndReady(observedPods[ready]); ready++);
    currentStatus = {replicas: Object.keys(observedPods).length, readyReplicas: ready};
\end{lstlisting}

如代码\ref{listing:catset-4}所示，为了支持滚动更新，还要把Pods按照编号排好序再返回，因为滚动更新是按照调谐结果中子资源列表中的顺序逐个更新的。对于一个Pod，只有编号靠前的Pods全部就绪，它才会被创建或者更新。如果开发者减小了spec.replicas，并且当前就绪的Pods数量大于它，就需要删除编号靠后的多余Pods。一次调谐最多只会增加或者删除一个Pod。当需要删除Pod时，不会删除这个Pod对应的PVC，PVC会在这个CatSet被删除时被清理。

\begin{lstlisting}[language=JavaScript,caption=返回的Pods,label=listing:catset-4,gobble=4]
    for (let ordinal in observedPods) {
      desiredPods[ordinal] = newPod(catset, ordinal);
    }
    if (ready < catset.spec.replicas && !(ready in desiredPods)) {
      desiredPods[ready] = newPod(catset, ready);
    }
    if (ready === catset.spec.replicas) {
      let maxOrdinal = Math.max(...Object.keys(desiredPods));
      if (maxOrdinal >= catset.spec.replicas) {
        delete desiredPods[maxOrdinal];
      }
    }
    for (let ordinal of Object.keys(desiredPods).sort((a, b) => a - b).reverse()) {
      desiredChildren.push(desiredPods[ordinal]);
    }
\end{lstlisting}


%\section{用例4：Customize钩子的用法}
%\subsection{介绍}
%本文实现了globalconfigmap-operator，用于介绍Customize钩子的用法。
%\subsection{实现}
%
%\begin{lstlisting}[language=Python,caption=,label=listing:]
%
%\end{lstlisting}
%
%\begin{lstlisting}[language=yaml,caption=globalconfigmap-controller的配置,label=listing:globalconfigmap-controller-config]
%apiVersion: universalcontroller.njuics.cn/v1alpha1
%kind: UniversalController
%metadata:
%  name: globalconfigmap-controller
%spec:
%  generateSelector: true
%  parentResource:
%    apiVersion: mlhub.njuics.cn/v1alpha1
%    resource: globalconfigmaps
%  childResources:
%  - apiVersion: v1
%    resource: configmaps
%    updateStrategy:
%      method: InPlace
%  hooks:
%    sync:
%      webhook:
%        url: http://globalconfigmap-controller.universalcontroller/sync
%    customize:
%      webhook:
%        url: http://globalconfigmap-controller.universalcontroller/customize
%\end{lstlisting}
%
%yaml文件\ref{globalconfigmap-controller-config}是用于在UniversalController中注册一个控制器的配置文件。
%
%\subsection{总结}
%因为globalcomfigmap-operator需要把一个ConfigMap复制到每个命名空间，所以开发者编写同步钩子时需要知道集群当前有哪些命名空间。

\section{用例对比与分析}


图\ref{fig:operator-cl}直观地展示了直接用client-go实现Operator与基于UC实现在工作量上的巨大差距。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.75\textwidth]{pics/operator-line.pdf}\\
  \caption{原版与UC版代码行数比较}\label{fig:operator-cl}
\end{figure}

原来的sample-controller是用Go语言实现的，总代码行数为1701，剔除使用代码生成工具生成的代码后代码行数为739。而借助UC，可以用JavaScript来编写业务逻辑，并且控制器配置和代码加起来也只有58行。对于功能简单的Operator，借助UC可以实现代码量很少的快速开发。

原版tf-operator主要使用了client-go包，实现了一个标准的Operator，Go代码行数为17155，剔除使用代码生成工具生成的代码以及测试代码后代码行数为2344，而基于UC实现的版本只需要四百多行JavaScript代码就能实现同样的功能。这个用例主要是为了展示UC在实现复杂Operator时依然具有保持工作量相对较小的能力。

CatSet重新实现了StatefulSet，并且支持滚动更新。为了支持滚动更新，开发者只需要编写YAML文件\ref{listing:catset-controller-config}的第16到第21行，为pods子资源加上滚动更新策略，以及编写代码\ref{listing:catset-4}的第13行到第15行将期望存在的Pods按照序号排序即可。开发者总共只添加了9行代码就让CatSet支持了滚动更新，而为了让StatefulSet支持滚动更新，Kubernetes开发者改动了业务逻辑、模版文件、生成的代码，总共涉及到了超过9000行的改动\cite{statefulsetupdate}。UC提供的声明式接口帮助开发者快速地使自己的应用支持滚动更新。

\section{性能测试}

Operator一般都不是计算型任务，运行时CPU的占用率极低，特别是在（超）小型集群中，接近于0。但是因为要监视资源，也就是订阅并且建立缓存，所以内存开销和网络开销才是重点。所以性能测试主要从这两个维度进行分析。

\subsection{实验环境}

在表\ref{table:test-env}所描述的集群上搭建了Kubernetes集群用于实验。
\begin{table}
  \centering
  \begin{tabular}{cp{60mm}c}
    \toprule
    \textbf{硬件类型} & \textbf{型号} & \textbf{规格} \\
    \midrule
    CPU  & Intel(R) Xeon(R) CPU E5-2630 v4 @ 2.20GHz  & 20核\\
    GPU  & NVIDIA 1080Ti   &  2 \\
    内存     & DDR4 & 128GB \\
    网卡    & Mellanox Technologies MT26448   & 10Gbps \\
    磁盘 & TOSHIBA MG04SCA20EN & 2TB \\
    \bottomrule
  \end{tabular}
  \caption{四节点集群的服务器配置}\label{table:test-env}
\end{table}

\subsection{对比方法}

我设计了八种场景，用于论证相比于部署多个Operators，使用UC可以消耗更少的内存和网络带宽。每个场景准备前都要清理环境，重新安装Kubernetes，之后部署100个只执行``sleep 365d''的Pod当做负载。我还实现了一种donothing-operator，它的CRD为DoNothing-<随机后缀>，它的控制器会订阅Pod和PVC，但是什么都不干。实现它的目的是为了方便实验。

接下来每个场景会安装不同的Operators：
\begin{itemize}
	\item \textbf{场景1}：不安装任何Operator。
	\item \textbf{场景2}：只安装UC。
	\item \textbf{场景3}：只安装原版的tf-operator。
	\item \textbf{场景4}：先安装UC，再安装重新实现的tf-operator。
	\item \textbf{场景5}：安装donothing-operator和原版的tf-operator。
	\item \textbf{场景6}：先安装UC，再安装重新实现的tf-operator以及catset-operator。
	\item \textbf{场景7}：安装两个donothing-operator和原版的tf-operator。
	\item \textbf{场景8}：先安装UC，再安装重新实现的tf-operator以及catset-operator，最后安装用UC重新实现的donothing-operator。
\end{itemize}

一个Opeator在安装之后，首先会与kube-apiserver进行同步，建立它关心的资源的缓存，所以启动之后会有一小段网络流量高峰，之后回落，再趋于平稳，内存也是先快速增长，之后趋于平稳。我会将每个场景中kube-apiserver在Operators启动后的前5分钟内上传的总数据量作为网络负载参考量，将之后5分钟内Operators所占用的总内存的平均值作为内存负载参考量。

\subsection{实验结果}
表\ref{table:test}汇总了各个场景的结果。场景1中没有任何Operator，但是每个节点的Kubelet都需要与kube-apiserver同步信息，所有也有很多数据需要传输。场景2中安装了UC，但是UC它只会监听UC CRD，Kubernetes中暂时没有任何UC CRD，所以kube-apiserver的网络负载几乎不变。场景3中tf-operator需要订阅TFJob、Pod、Service，所以kube-apiserver的网络负载增加了不少。

对比场景3和场景4可以看到，因为UC控制器自身带来的负载，重新实现的tf-operator的内存和网络负载都要比原版的tf-operator要高。

对比场景5和场景6可以看到，再增加一个operator后，场景5的内存和网络负载要更高，比场景3增长很多，而场景6与场景4的负载很接近。tf-operator和catset-operator都需要订阅Pod资源，但是当它们都部署在UC之上时，Pod资源只会被订阅一次，这部分就不会带来额外的负载，catset-operator还需要订阅Service和CatSet，但是我们当前集群中主要的资源都是Pod，Service很少，还没有CatSet，所以也没有产生很多负载。场景8相对场景6的资源增量，以及场景7相对场景5的资源增量也反映了这一点。

借助UC的共享通知器（SharedInformer），当部署多个Operators时，将Operators部署在UC之上要比每个Operator单独部署占用更少的内存和网络带宽。
\begin{table}
  \centering
  \begin{tabular}{ccc}
    \toprule
    \textbf{场景编号} & \textbf{Operators内存总用量（MB）} & \textbf{5分钟内上传数据量（KB）} \\
    \midrule
    1  & 0 & 11995.14 \\
    2  & 12.52  &  12012.05 \\
    3  & 13.87  & 13297.24 \\
    4  & 19.18 &  13438.46 \\
    5  & 25.78  & 14529.64 \\
    6  & 21.93  & 13542.36 \\
    7  & 37.84  & 15839.75 \\
    8  & 23.13  & 13708.53 \\
    \bottomrule
  \end{tabular}
  \caption{性能测试}\label{table:test}
\end{table}

\section{小结}
本章设计了多个用例，用UC实现了三个功能各异的Kubernetes Operators，验证了UC可以简化Operator的实现，并且有很强的通用性。

本章设计的性能测试验证了UC借助于共享通知者（sharedInformer），避免了重复订阅同一个资源，相比于一般的多控制器部署方式对内存和网络的占用更小。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 学位论文的正文应以《结论》作为最后一章
\chapter{总结和展望}\label{chapter_concludes}
\section{工作总结}
随着云计算的蓬勃发展，新技术不断涌现。Docker和Kubernetes的出现更是重要的里程碑。Kubernetes已经成为了容器编排的实时标准，是云计算重要的基础设施。但是Kubernetes提供的现有APIs不一定能够很好的满足使用者的需求，使用者经常需要去扩展Kubernetes以更好的支持自己的应用的部署、更新和维护。最主流的Kubernetes扩展方式就是Kubernetes Operators，大量的Operators开始在开源社区出现。然而，编写一个Operator并不容易，具有相当高的门槛，并且需要付出大量的精力和时间。Operator开发人员需要一定程度的Kubernetes和分布式系统知识，需要写大量的模版代码或者使用代码生成工具，编写出的Operator帮助我们实现了应用程序的自动化运维，但是维护这个Operator却还是要给开发人员带来很大的负担。

本文针对现有Operator开发方式中存在的模版代码冗余、非功能性代码繁多、非Go语言使用者开发困难等问题，提出了一种声明式的通用Kubernetes调谐技术。该技术采用的方法是（1）封装编写自定义控制器的一般部分，例如资源监视、当前状态与期望状态对比、资源更新等；（2）将核心的自定义调谐逻辑单独抽取出来让开发者实现，并通过服务端应用实现声明式开发；（3）扩展Kubernetes的API，添加一种新的自定义资源，用于描述自定义控制器，自定义控制器通过该自定义资源动态定义，在运行时调用实际提供调谐逻辑的服务。该技术为开发者开发Operator提供一种简单的声明式方法，让开发者将注意力完全集中在核心调谐逻辑上，摆脱Go语言、Kubernetes开发工具包、代码生成工具的学习与使用成本。自定义资源和自定义控制器都借助Kubernetes的声明式api创建，而且开发者可以使用任意可以处理JSON和网络请求的编程语言来实现一个Operator。

本文将基于声明式的通用Kubernetes调谐技术实现的工具称为UniversalController，它是一个声明式的通用Kubernetes Operator，底层实现依然是经典的Operator模式。借助UniversalController提供的声明式API，尤其是声明式调谐接口，开发者为核心业务逻辑编写的代码也是声明式的，可以用任意一种能够处理JSON\footnote{https://www.json.org/json-en.html}的编程语言来实现，只需要用JSON编写期望存在的资源即可。如果开发者已经很熟悉使用YAML编写资源定义文件并用``kubectl apply''命令部署来管理应用这种基本的Kubernetes使用方式，那么就可以很容易地基于UniversalController实现一个Operator为应用的部署、更新、维护提供自动化流程而不必去学习Go语言或者如何使用Kubernetes客户端库，也不需要去学习使用代码生成工具。

总而言之，本文的主要贡献包括：

\begin{enumerate}
	\item 针对Operator开发中存在的模版代码冗余、非功能性代码繁多、非Go语言使用者开发困难等问题，提出一种声明式的通用调谐技术，封装编写自定义控制器的一般部分，将核心的自定义调谐逻辑单独抽取出来让开发者实现；添加一种新的自定义资源，用于描述自定义控制器，自定义控制器通过该自定义资源动态定义，在运行时调用实际提供调谐逻辑的服务。该技术简化需要编写的代码，大量减少Operator开发者的工作量，帮助开发者将精力集中在业务逻辑上，即描述期望状态上。
	\item 基于声明式的通用调谐技术实现了声明式的通用Kubernetes Operator，UniverslController，该工具具有声明式的资源监视，声明式的调谐、声明式的更新策略和语言无关的特性，开发者不需要编写任何与Kubernetes交互的代码，只需要在YAML文件中描述需要监视的资源、使用的更新策略以及在调谐代码段中描述期望的状态即可。该工具帮助开发者免除学习Kubernetes客户端库、控制器抽象库或其他工具的负担，也消除了编写或生成模版代码的必要。
	\item 基于UniversalController重新实现了一些现有的Operators，验证了UniversalController可以显著缩减开发工作量，并且适用于大部分场景的开发，并通过性能测试验证了它还能在多自定义控制器部署的环境中减少内存消耗和kube-apiserver的负载。
\end{enumerate}


\section{未来展望}
本文提出的工作将Kubernetes操作相关的代码从业务逻辑中提取了出来，开发者不用再关注Kubernetes的Client API，让开发者将开发工作集中在业务逻辑上，帮助开发者减少了大量的开发工作。同时，本文仍然存在需要在未来工作中进行改进的地方。

本文提出的工作让开发者将开发工作集中在业务逻辑上，但是开发者必须借助serverless工具或者自己编写网络处理相关代码来启动一个web服务，以便与UniversalController对接。未来的工作中会加入更多的机制，例如gRPC或者嵌入式的脚本代码，让开发者可以有更多的选择。或者可以将UniversalController的一部分封装成更加通用的库，提供一些方便的开发接口，开发者可以将业务逻辑实现成系统内部的代码调用，这样就不用将业务逻辑放在UniversalController的外部组件内，省去网络通信的开销。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 致谢，应放在《结论》之后
\begin{acknowledgement}
  硕士漫漫三年这么快就过去了，在此期间我相识很多为我提供很多帮助或欢乐的人，由衷地感谢他们。
  
首先，也是最主要感谢的是我的指导老师，曹春老师。在我的硕士阶段都及时适当的提点我，让我思路贯通，他的细心指导是我顺利完成研究的最大助力。

我还要感谢我的朋友们，谢谢大家三年来给我的关心、信任和帮助，谢谢你们陪我走过人生一段美好时光。

最后，深深感谢我的父母和亲人。这些年，您们无私而无微不至的关心和鼓 励，让我从不孤单。

在此，我衷心感谢所有帮助我的人，没有你们我不可能完成这项工作，没有你们我的三年不会如此充实，真心感谢您们!
\end{acknowledgement}

% 参考文献。应放在\backmatter之前。
% 推荐使用BibTeX，若不使用BibTeX时注释掉下面一句。
\nocite{*}
\bibliography{sample}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 附录
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 书籍附件
\backmatter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 作者简历与科研成果页，应放在backmatter之后
\begin{resume}
% 论文作者身份简介，一句话即可。
\begin{authorinfo}
\noindent 汪浩港，男，汉族，1996年12月出生，江苏省扬州人。
\end{authorinfo}
% 论文作者教育经历列表，按日期从近到远排列，不包括将要申请的学位。
\begin{education}
\item[2018年9月 --- 2021年6月] 南京大学计算机科学与技术系 \hfill 硕士
\item[2014年9月 --- 2018年6月] 中国矿业大学计算机科学与技术系 \hfill 本科
\end{education}
% 论文作者在攻读学位期间所发表的文章的列表，按发表日期从近到远排列。
\begin{publications}
\item 发明技术专利：一种声明式的通用Kubernetes调谐方法（专利号：202110558547.3）
\item 软件著作权： 人机物融合资源管理云平台（登记号：2020SR1657985），2020年11月26日
\end{publications}

% 论文作者在攻读学位期间参与的科研课题的列表，按照日期从近到远排列。
\begin{projects}
	\item 国家重点研发项目：软件定义的人机物融合云计算支撑技术与平台（2018YFB004805），2018年5月-2021年4月
\end{projects}
\end{resume}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 生成《学位论文出版授权书》页面，应放在最后一页
\makelicense

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
